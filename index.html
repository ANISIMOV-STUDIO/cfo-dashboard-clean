<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CFO Dashboard</title>
    <style>
        /* CFO Dashboard CSS - iOS-like чистый стиль для старого WebKit */

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
            line-height: 1.4;
            font-size: 14px;
            -webkit-font-smoothing: antialiased;
            overflow-x: auto;
            min-width: 1200px;
        }
        
        :root {
            --header-h: 160px; /* Default fallback, will be updated by JS */
        }
        
        body {
            margin: 0;
            padding: 0;
        }

        .dashboard {
            padding: 0;
            max-width: none;
            min-height: 100vh;
            padding-top: var(--header-h); /* B1: Dynamic header height */
        }

        /* C1: Fixed header - macOS style */
        .dashboard-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.95) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(189, 195, 199, 0.3);
            box-shadow: 0 2px 20px rgba(52, 73, 94, 0.1);
            padding: 16px;
        }

        /* Топовая полоса KPI */
        .kpi-bar {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: nowrap;
            overflow-x: auto;
        }

        .kpi-card {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 12px;
            padding: 16px 20px;
            min-width: 200px;
            flex: 1;
            border: 1px solid #bdc3c7;
            box-shadow: 0 4px 6px rgba(52, 73, 94, 0.1);
            position: relative;
            transition: all 0.15s ease;
        }

        .kpi-card:hover {
            transform: translateY(-2px);
            border-color: #3498db;
            box-shadow: 0 8px 15px rgba(52, 73, 94, 0.15);
        }

        .kpi-title {
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .kpi-value {
            font-size: 28px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
            line-height: 1.1;
        }

        .kpi-change {
            font-size: 12px;
            font-weight: 500;
        }

        .kpi-change.positive { color: #27ae60; }
        .kpi-change.negative { color: #e74c3c; }
        .kpi-change.warning { color: #f39c12; }
        .kpi-change.neutral { color: #95a5a6; }

        .margin-selector {
            font-size: 11px;
            border: none;
            background: transparent;
            color: #7f8c8d;
            cursor: pointer;
            margin-left: 4px;
        }

        /* Error boundary - шильдик об ошибках */
        .error-boundary {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #e74c3c;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            z-index: 10000;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .error-boundary:hover {
            background: #c0392b;
            transform: translateY(-1px);
        }

        .error-boundary.expanded {
            max-width: 600px;
            max-height: 300px;
            overflow-y: auto;
        }

        .error-details {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            white-space: pre-wrap;
            display: none;
        }

        .error-boundary.expanded .error-details {
            display: block;
        }

        .error-actions {
            margin-top: 8px;
            display: none;
        }

        .error-boundary.expanded .error-actions {
            display: flex;
            gap: 8px;
        }

        .error-btn {
            padding: 4px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .error-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* D1: Баннер рекомендаций - умные подсказки */
        .recommendations-banner {
            position: fixed;
            top: calc(var(--header-h) + 10px);
            left: 20px;
            right: 20px;
            z-index: 999;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3);
            display: none;
            animation: slideInDown 0.3s ease-out;
        }

        @keyframes slideInDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .recommendations-banner.show {
            display: block;
        }

        .banner-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .banner-title {
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .banner-content {
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 16px;
        }

        .banner-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .banner-btn {
            padding: 8px 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .banner-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .banner-btn.primary {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .banner-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-size: 18px;
            padding: 4px;
            border-radius: 4px;
            transition: color 0.2s ease;
        }

        .banner-close:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        /* Основная сетка */
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        .chart-container {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 12px;
            border: 1px solid #bdc3c7;
            box-shadow: 0 4px 8px rgba(52, 73, 94, 0.1);
            overflow: hidden;
            position: relative;
        }

        .chart-header {
            padding: 16px 20px 12px;
            border-bottom: 1px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(145deg, #fafbfc 0%, #ecf0f1 100%);
        }

        .chart-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .chart-controls {
            display: flex;
            gap: 8px;
        }

        .toggle-btn {
            padding: 4px 12px;
            font-size: 11px;
            border: 1px solid #bdc3c7;
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            color: #7f8c8d;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .toggle-btn:hover {
            border-color: #007aff;
            color: #007aff;
        }

        .toggle-btn.active {
            background: #007aff;
            color: #ffffff;
            border-color: #007aff;
        }

        /* Scenario controls for cash forecast */
        .scenario-controls {
            display: flex;
            gap: 6px;
        }

        .scenario-btn {
            padding: 4px 12px;
            font-size: 11px;
            border: 1px solid #bdc3c7;
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            color: #7f8c8d;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scenario-btn:hover {
            border-color: #27ae60;
            color: #27ae60;
        }

        .scenario-btn.active {
            background: #27ae60;
            color: #ffffff;
            border-color: #27ae60;
        }

        /* Forecast details */
        .forecast-details {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #ecf0f1;
        }

        .forecast-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        .forecast-column h4 {
            font-size: 12px;
            color: #7f8c8d;
            margin: 0 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .forecast-column {
            font-size: 13px;
            line-height: 1.4;
        }

        /* EBITDA drivers legend */
        .drivers-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-color.price { background: #3498db; }
        .legend-color.volume { background: #27ae60; }
        .legend-color.mix { background: #f39c12; }
        .legend-color.fx { background: #9b59b6; }
        .legend-color.cogs { background: #e74c3c; }
        .legend-color.opex { background: #34495e; }

        /* Print styles for A4/A3 layout (Task 5 - Sprint 5) */
        @media print {
            * {
                -webkit-print-color-adjust: exact !important;
                color-adjust: exact !important;
            }
            
            /* Print-specific visibility classes */
            .print-hidden {
                display: none !important;
            }
            
            body {
                background: white !important;
                margin: 0;
                padding: 0;
                font-size: 11px;
            }
            
            .dashboard {
                padding: 10mm;
                background: white;
                min-height: auto;
            }
            
            /* Hide interactive elements */
            .filters-header,
            .alerts-panel,
            .alerts-bell,
            .scenario-btn,
            .toggle-btn,
            .chart-controls,
            .print-controls {
                display: none !important;
            }
            
            /* Page header for print */
            .print-header {
                display: block !important;
                margin-bottom: 5mm;
                padding-bottom: 3mm;
                border-bottom: 1pt solid #bdc3c7;
            }
            
            .print-header h1 {
                font-size: 16pt;
                margin: 0;
                color: #2c3e50;
            }
            
            .print-header .print-info {
                font-size: 9pt;
                color: #7f8c8d;
                margin-top: 2mm;
            }
            
            /* KPI cards for print */
            .kpi-bar {
                flex-wrap: wrap;
                margin-bottom: 5mm;
                gap: 3mm;
            }
            
            .kpi-card {
                min-width: 40mm;
                padding: 3mm 4mm;
                break-inside: avoid;
                border: 1pt solid #bdc3c7;
                box-shadow: none;
            }
            
            /* Charts and containers */
            .chart-container {
                break-inside: avoid;
                margin-bottom: 5mm;
                border: 1pt solid #bdc3c7;
                box-shadow: none;
            }
            
            .chart-header {
                padding: 3mm 4mm;
                background: #f8f9fa !important;
                border-bottom: 1pt solid #ecf0f1;
            }
            
            .chart-header h3 {
                font-size: 12pt;
                margin: 0;
            }
            
            .chart-body {
                padding: 4mm;
            }
            
            /* Canvas elements */
            .chart-body canvas {
                max-width: 100%;
                height: auto;
            }
            
            /* Tables */
            .debtors-table,
            .accounts-table,
            .coefficients-grid {
                font-size: 8pt;
                page-break-inside: avoid;
            }
            
            /* Page breaks */
            .page-content {
                page-break-after: always;
            }
            
            .page-content:last-child {
                page-break-after: auto;
            }
            
            /* A4 landscape specific */
            @page {
                size: A4 landscape;
                margin: 15mm 10mm;
            }
            
            .dashboard.print-a3 {
                /* A3 landscape layout */
            }
            
            .dashboard.print-a3 .kpi-card {
                min-width: 50mm;
                padding: 4mm 5mm;
            }
            
            .dashboard.print-a3 .chart-container {
                margin-bottom: 8mm;
            }
            
            /* Emojis replacement with SVG icons */
            .alert-type-icon {
                width: 3mm;
                height: 3mm;
                display: inline-block;
                background-size: contain;
            }
            
            .alert-type-icon.cash-shortage::before {
                content: "⚠";
                font-style: normal;
            }
            
            .alert-type-icon.overdue::before {
                content: "⏰";
                font-style: normal;
            }
            
            .alert-type-icon.covenant-breach::before {
                content: "📊";
                font-style: normal;
            }
            
            .alert-type-icon.concentration::before {
                content: "🏦";
                font-style: normal;
            }

            /* E1: Расширенные стили печати - лого, страницы, поля */
            
            /* Добавляем лого в print header */
            .print-header::before {
                content: "";
                display: inline-block;
                width: 12mm;
                height: 12mm;
                background: #2c3e50;
                border-radius: 2mm;
                margin-right: 4mm;
                vertical-align: middle;
                position: relative;
            }
            
            .print-header::before {
                /* Простой текстовый лого для совместимости */
                background: none;
                color: #2c3e50;
                content: "CFO";
                font-weight: bold;
                font-size: 10pt;
                width: auto;
                height: auto;
                border: 2pt solid #2c3e50;
                padding: 1mm 2mm;
                border-radius: 2mm;
            }
            
            /* Правильные поля для A4 landscape */
            @page {
                size: A4 landscape;
                margin: 15mm;
            }
            
            /* Для A3 */
            .dashboard.print-a3 {
                page: a3;
            }
            
            @page a3 {
                size: A3 landscape;
                margin: 20mm;
            }
            
            /* Нумерация страниц */
            .print-header .print-info::after {
                content: " • Стр. " counter(page) " из " counter(pages);
                color: #7f8c8d;
            }
            
            /* Принудительные разрывы страниц между разделами дашборда */
            .page-content:not(.active) {
                display: none !important;
            }
            
            .page-content.print-page {
                display: block !important;
                page-break-before: always;
            }
            
            .page-content.print-page:first-child {
                page-break-before: avoid;
            }
            
            /* Скрываем навигацию и интерактивы */
            .page-navigation,
            .segment-control,
            .recommendations-banner,
            .error-boundary,
            .dashboard-header,
            .export-controls,
            .banner-actions,
            .toggle-switch,
            .filter-select,
            .preset-btn {
                display: none !important;
            }
            
            /* Убираем фиксированные элементы */
            .dashboard {
                padding-top: 0 !important;
            }
            
            /* Компактная сетка для печати */
            .page-body {
                height: auto !important;
                grid-gap: 4mm !important;
                padding: 0 !important;
            }
            
            /* Каждый chart-container помещается без обрезания */
            .chart-container {
                min-height: 60mm;
                max-height: 90mm;
                page-break-inside: avoid;
            }
            
            /* KPI карточки в одну строку */
            .kpi-bar {
                display: flex !important;
                flex-wrap: nowrap;
                justify-content: space-between;
                page-break-inside: avoid;
            }
            
            .kpi-card {
                flex: 1;
                margin: 0 1mm;
                min-width: auto !important;
            }
            
            /* Таблицы адаптируются под печать */
            .debtors-table,
            .accounts-table {
                font-size: 8pt;
                break-inside: auto;
            }
            
            .debtors-table td,
            .accounts-table td {
                padding: 1mm 2mm;
            }
            
            /* Временные метки */
            .print-info::before {
                content: "Сформирован: " attr(data-print-time) " • ";
            }
        }

        .chart-body {
            padding: 20px;
            position: relative;
            min-height: 300px;
        }

        .chart-body canvas {
            max-width: 100%;
            height: auto !important;
        }

        /* Дебиторка */
        .debtors-summary {
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .aging-buckets {
            display: flex;
            gap: 12px;
        }

        .bucket {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            color: #ffffff;
        }

        .bucket-0-30 { background: #34c759; }
        .bucket-31-60 { background: #ff9500; }
        .bucket-61-90 { background: #ff6347; }
        .bucket-90 { background: #ff3b30; }

        .dso-indicator {
            font-size: 14px;
            font-weight: 600;
            color: #1a1a1a;
        }

        .debtors-table, .accounts-table {
            width: 100%;
            font-size: 12px;
        }

        .debtors-table th,
        .debtors-table td,
        .accounts-table th,
        .accounts-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #f1f3f4;
        }

        .debtors-table th,
        .accounts-table th {
            background: #fafbfc;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
        }

        /* Enhanced дебиторка стили */
        .debtors-table th[title] {
            cursor: pointer;
            position: relative;
        }

        .debtors-table th[title]:hover {
            background: #f0f4f8;
            color: #007aff;
        }

        .debtors-table .sla-good { background: rgba(52, 199, 89, 0.1); }
        .debtors-table .sla-caution { background: rgba(255, 149, 0, 0.1); }
        .debtors-table .sla-warning { background: rgba(255, 99, 71, 0.1); }
        .debtors-table .sla-critical { background: rgba(255, 59, 48, 0.15); }

        .debtors-table .has-overdue {
            color: #ff3b30;
            font-weight: 600;
        }

        .debtors-table .high-util {
            color: #ff9500;
            font-weight: 600;
        }

        .debtors-table .summary-row {
            background: #f8f9fa;
            border-top: 2px solid #007aff;
            font-weight: 600;
        }

        .debtors-table .amount {
            text-align: right;
            font-family: 'SF Mono', monospace;
        }

        .bucket-cell {
            text-align: center;
        }

        /* Финансовые коэффициенты */
        .coefficients-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
        }

        .coefficient-card {
            padding: 12px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            text-align: center;
            position: relative;
        }

        .coefficient-name {
            font-size: 11px;
            color: #8e8e93;
            font-weight: 500;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .coefficient-value {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .coefficient-target {
            font-size: 10px;
            color: #6b7280;
        }

        .coefficient-sparkline {
            width: 100%;
            height: 30px;
            margin-top: 8px;
        }

        /* Cash accounts */
        .cash-summary {
            margin-bottom: 16px;
            text-align: center;
        }

        .runway-indicator {
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
        }

        .runway-indicator span {
            color: #ff9500;
        }

        /* Алерты */
        .alerts-bell {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            cursor: pointer;
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #bdc3c7;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(52, 73, 94, 0.15);
            transition: all 0.15s ease;
        }

        .alerts-bell:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(52, 73, 94, 0.2);
        }

        .alerts-bell-icon {
            width: 20px;
            height: 20px;
            color: #2c3e50;
            transition: color 0.15s ease;
        }

        .alerts-bell.has-critical .alerts-bell-icon {
            color: #ff3b30;
            animation: bell-shake 0.5s ease-in-out infinite;
        }

        .alerts-counter {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #ff3b30;
            color: white;
            border-radius: 50%;
            min-width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            border: 2px solid white;
        }

        .alerts-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 360px;
            max-height: calc(100vh - var(--header-h));
            z-index: 1000;
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #bdc3c7;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(52, 73, 94, 0.15);
            overflow: hidden;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .alerts-panel.open {
            transform: translateX(0);
        }

        .alerts-header {
            padding: 16px 20px;
            border-bottom: 1px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(145deg, #fafbfc 0%, #ecf0f1 100%);
        }

        .alerts-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .alerts-filter {
            display: flex;
            gap: 8px;
        }

        .severity-filter-btn {
            padding: 4px 8px;
            font-size: 10px;
            border: 1px solid #bdc3c7;
            background: #ffffff;
            color: #7f8c8d;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-weight: 500;
            text-transform: uppercase;
        }

        .severity-filter-btn:hover {
            border-color: #007aff;
            color: #007aff;
        }

        .severity-filter-btn.active {
            background: #007aff;
            color: #ffffff;
            border-color: #007aff;
        }

        .alerts-body {
            max-height: 400px;
            overflow-y: auto;
            padding: 8px;
        }

        .alert-item {
            background: #ffffff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 8px;
            border-left: 4px solid;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            font-size: 12px;
            position: relative;
            transition: all 0.15s ease;
        }

        .alert-item:hover {
            transform: translateX(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        .alert-item.severity-low { border-left-color: #34c759; }
        .alert-item.severity-medium { border-left-color: #ff9500; }
        .alert-item.severity-high { border-left-color: #ff6347; }
        .alert-item.severity-critical { border-left-color: #ff3b30; }

        .alert-item.highlighted {
            animation: highlight-fade 1.5s ease-out;
        }

        @keyframes highlight-fade {
            0% { background-color: #007aff; transform: scale(1.02); }
            100% { background-color: #ffffff; transform: scale(1.0); }
        }

        @keyframes bell-shake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg); }
            75% { transform: rotate(10deg); }
        }

        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 6px;
        }

        .alert-title {
            font-weight: 600;
            color: #1a1a1a;
            flex: 1;
        }

        .alert-actions {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }

        .alert-action-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            color: #7f8c8d;
            font-size: 14px;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.15s ease;
        }

        .alert-action-btn:hover {
            background: #f1f3f4;
            color: #2c3e50;
        }

        .alert-message {
            color: #6b7280;
            line-height: 1.3;
            margin-bottom: 8px;
        }

        .alert-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: #95a5a6;
        }

        .alert-time {
            font-weight: 500;
        }

        .alert-source-link {
            color: #007aff;
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
        }

        .alert-source-link:hover {
            text-decoration: underline;
        }

        .snooze-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1002;
            min-width: 120px;
        }

        .snooze-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 11px;
            border-bottom: 1px solid #ecf0f1;
            transition: background 0.15s ease;
        }

        .snooze-option:last-child {
            border-bottom: none;
        }

        .snooze-option:hover {
            background: #f8f9fa;
        }

        .alerts-empty {
            text-align: center;
            padding: 40px 20px;
            color: #7f8c8d;
            font-size: 12px;
        }

        .alerts-empty-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 12px;
            opacity: 0.5;
        }

        /* IBCS цветовая схема */
        .ibcs-fact { color: #1a1a1a; }
        .ibcs-plan { color: #1a1a1a; background: transparent; }
        .ibcs-prev-year { color: #8e8e93; }
        .ibcs-forecast { color: #007aff; }
        .ibcs-positive { color: #34c759; }
        .ibcs-negative { color: #ff3b30; }

        /* Responsive для маленьких экранов */
        @media (max-width: 1400px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .kpi-bar {
                flex-wrap: wrap;
            }
            
            .kpi-card {
                min-width: 180px;
            }
        }

        /* Spinner для загрузки */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border: 2px solid #e1e5e9;
            border-top: 2px solid #007aff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Фильтры */
        .filters-header {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            margin: 8px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
            font-size: 12px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .filter-label {
            font-size: 10px;
            color: #7f8c8d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-select, .filter-input {
            padding: 6px 12px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            background: #ffffff;
            color: #2c3e50;
            font-size: 12px;
            min-width: 120px;
            transition: all 0.15s ease;
        }

        .filter-select:focus, .filter-input:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
        }

        .filter-select:hover, .filter-input:hover {
            border-color: #007aff;
        }

        .period-presets {
            display: flex;
            gap: 8px;
        }

        .preset-btn {
            padding: 6px 12px;
            font-size: 11px;
            border: 1px solid #bdc3c7;
            background: #ffffff;
            color: #7f8c8d;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preset-btn:hover {
            border-color: #007aff;
            color: #007aff;
        }

        .preset-btn.active {
            background: #007aff;
            color: #ffffff;
            border-color: #007aff;
        }

        .filter-checkboxes {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
            transform: scale(1.1);
        }

        .checkbox-item label {
            font-size: 11px;
            color: #2c3e50;
            cursor: pointer;
            margin: 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #bdc3c7;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #007aff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .date-range-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .date-separator {
            color: #7f8c8d;
            font-weight: 500;
        }

        /* Клавиатурная навигация и доступность */
        .filter-select:focus, .filter-input:focus, 
        .toggle-btn:focus, .preset-btn:focus, 
        .severity-filter-btn:focus, .alert-action-btn:focus {
            outline: 2px solid #007aff;
            outline-offset: 2px;
        }

        .checkbox-item:focus-within,
        .toggle-switch:focus-within {
            outline: 2px solid #007aff;
            outline-offset: 2px;
            border-radius: 4px;
        }

        /* Улучшенные focus стили для алертов */
        .alert-item:focus-within {
            outline: 2px solid #007aff;
            outline-offset: 2px;
            border-radius: 8px;
        }

        /* Улучшенная видимость для hover состояний */
        .chart-container:focus-within {
            outline: 2px solid #007aff;
            outline-offset: 2px;
        }

        /* Скрытые элементы для screen readers */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Навигация (Sprint 4) */
        .page-navigation {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #bdc3c7;
            border-radius: 12px;
            padding: 8px;
            margin: 16px 0 24px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(52, 73, 94, 0.08);
        }
        
        .navigation-center {
            flex: 1;
            display: flex;
            justify-content: center;
        }
        
        .export-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .export-page-btn {
            background: linear-gradient(135deg, #34c759 0%, #30d158 100%);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(52, 199, 89, 0.2);
            min-width: auto;
        }
        
        .export-page-btn:hover {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 2px 6px rgba(52, 199, 89, 0.3);
            transform: translateY(-0.5px);
        }
        
        .export-page-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(52, 199, 89, 0.2);
        }
        
        .export-all-btn {
            background: linear-gradient(135deg, #007aff 0%, #5856d6 100%);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.2);
            min-width: auto;
        }
        
        .export-all-btn:hover {
            background: linear-gradient(135deg, #0051d5 0%, #4c44b8 100%);
            box-shadow: 0 2px 6px rgba(0, 122, 255, 0.3);
            transform: translateY(-0.5px);
        }
        
        /* F2: Enhanced sharpness and contrast optimizations */
        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }
        
        /* High-contrast text improvements */
        .kpi-value, .section-title, .metric-label {
            font-weight: 600;
            text-shadow: 0 0.5px 0 rgba(0, 0, 0, 0.05);
            letter-spacing: -0.025em;
        }
        
        .kpi-value {
            color: #1a1a1a;
            font-weight: 700;
        }
        
        .section-title {
            color: #2c3e50;
            font-weight: 600;
        }
        
        .metric-label {
            color: #34495e;
            font-weight: 500;
        }
        
        /* Enhanced card contrast */
        .kpi-card, .chart-container, .alert-card {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08), 0 1px 3px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }
        
        .kpi-card:hover, .chart-container:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12), 0 2px 6px rgba(0, 0, 0, 0.16);
            border-color: rgba(0, 0, 0, 0.08);
        }
        
        /* Chart enhancement for better visibility */
        canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* Improved button contrast */
        .segment-tab {
            font-weight: 500;
            text-shadow: none;
        }
        
        .segment-tab.active {
            color: #1a1a1a;
            font-weight: 600;
            text-shadow: 0 0.5px 0 rgba(255, 255, 255, 0.8);
        }
        
        /* Enhanced navigation contrast */
        .page-navigation {
            border-bottom: 2px solid rgba(0, 0, 0, 0.08);
        }
        
        /* Better table contrast */
        .debtors-table th, .accounts-table th {
            background: #f8f9fa;
            color: #2c3e50;
            font-weight: 600;
            border-bottom: 2px solid #e9ecef;
        }
        
        .debtors-table td, .accounts-table td {
            border-bottom: 1px solid #dee2e6;
            color: #495057;
        }
        
        /* Alert banner improvements */
        .alert-banner {
            border-left: 4px solid;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .alert-banner.high {
            border-left-color: #dc3545;
            background: linear-gradient(135deg, #fff5f5 0%, #fef2f2 100%);
            color: #721c24;
        }
        
        .alert-banner.medium {
            border-left-color: #fd7e14;
            background: linear-gradient(135deg, #fffaf0 0%, #fef7ed 100%);
            color: #8a4214;
        }
        
        .alert-banner.low {
            border-left-color: #28a745;
            background: linear-gradient(135deg, #f0fff4 0%, #f0fdf4 100%);
            color: #166534;
        }

        /* E2: Batch export button styling */
        .batch-export-btn {
            background: linear-gradient(135deg, #34c759 0%, #30a14e 100%);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s ease;
        }
        
        .batch-export-btn:hover {
            background: linear-gradient(135deg, #28a745 0%, #2d8f40 100%);
            box-shadow: 0 2px 6px rgba(52, 199, 89, 0.3);
            transform: translateY(-0.5px);
        }
        
        .batch-export-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(52, 199, 89, 0.4);
        }

        .segmented-control {
            display: flex;
            background: #e8eaed;
            border-radius: 8px;
            padding: 2px;
            position: relative;
            max-width: 600px;
        }

        .segment-tab {
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 500;
            color: #5f6368;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            z-index: 2;
            min-width: 80px;
            text-align: center;
        }

        .segment-tab:hover {
            color: #007aff;
        }

        .segment-tab:focus {
            outline: 2px solid #007aff;
            outline-offset: 2px;
        }

        /* C1: macOS-style tabs */
        .segment-tab.active {
            color: #1a1a1a;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .segment-tab[aria-current="page"] {
            font-weight: 600;
        }

        /* Макс-подобные переходы */
        .segment-tab.active::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(145deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 8px;
            z-index: -1;
            opacity: 0;
            animation: segment-glow 0.2s ease-out forwards;
        }

        @keyframes segment-glow {
            to { opacity: 1; }
        }

        /* Плотность компонентов */
        .dashboard.density-compact .segment-tab {
            padding: 6px 12px;
            font-size: 11px;
        }

        .dashboard.density-comfort .segment-tab {
            padding: 10px 20px;
            font-size: 13px;
        }

        /* Compact density adjustments */
        .dashboard.density-compact .kpi-bar {
            padding: 16px 20px;
        }

        .dashboard.density-compact .kpi-card {
            padding: 8px 12px;
        }

        .dashboard.density-compact .kpi-title {
            font-size: 11px;
            margin-bottom: 2px;
        }

        .dashboard.density-compact .kpi-value {
            font-size: 20px;
        }

        .dashboard.density-compact .kpi-change {
            font-size: 10px;
        }

        .dashboard.density-compact .chart-container {
            padding: 12px;
        }

        .dashboard.density-compact .chart-header {
            margin-bottom: 8px;
        }

        .dashboard.density-compact .chart-header h3 {
            font-size: 13px;
            margin: 0;
        }

        .dashboard.density-compact .chart-controls {
            gap: 6px;
        }

        .dashboard.density-compact .toggle-btn {
            padding: 4px 8px;
            font-size: 10px;
        }

        .dashboard.density-compact .page-body {
            gap: 8px;
            padding: 0 16px;
        }

        .dashboard.density-compact .filter-group {
            gap: 2px;
        }

        .dashboard.density-compact .filter-label {
            font-size: 9px;
        }

        .dashboard.density-compact .filter-select, 
        .dashboard.density-compact .filter-input {
            padding: 4px 8px;
            font-size: 11px;
            min-width: 100px;
        }

        .dashboard.density-compact .preset-btn {
            padding: 4px 8px;
            font-size: 10px;
        }

        .dashboard.density-compact .filters-header {
            padding: 12px 16px;
            gap: 12px;
        }

        /* Comfort density adjustments */
        .dashboard.density-comfort .kpi-bar {
            padding: 24px;
        }

        .dashboard.density-comfort .kpi-card {
            padding: 16px 20px;
        }

        .dashboard.density-comfort .kpi-title {
            font-size: 13px;
            margin-bottom: 6px;
        }

        .dashboard.density-comfort .kpi-value {
            font-size: 28px;
        }

        .dashboard.density-comfort .kpi-change {
            font-size: 12px;
        }

        .dashboard.density-comfort .chart-container {
            padding: 20px;
        }

        .dashboard.density-comfort .chart-header {
            margin-bottom: 16px;
        }

        .dashboard.density-comfort .chart-header h3 {
            font-size: 16px;
            margin: 0;
        }

        .dashboard.density-comfort .chart-controls {
            gap: 12px;
        }

        .dashboard.density-comfort .toggle-btn {
            padding: 8px 16px;
            font-size: 12px;
        }

        .dashboard.density-comfort .page-body {
            gap: 20px;
            padding: 0 24px;
        }

        .dashboard.density-comfort .filter-group {
            gap: 6px;
        }

        .dashboard.density-comfort .filter-label {
            font-size: 11px;
        }

        .dashboard.density-comfort .filter-select, 
        .dashboard.density-comfort .filter-input {
            padding: 8px 16px;
            font-size: 13px;
            min-width: 140px;
        }

        .dashboard.density-comfort .preset-btn {
            padding: 8px 16px;
            font-size: 12px;
        }

        .dashboard.density-comfort .filters-header {
            padding: 20px 24px;
            gap: 20px;
        }

        /* Страницы контента */
        /* C1: Плавные переходы fade/slide 120-160ms без CSS-масштаба */
        .page-content {
            display: none;
            opacity: 0;
            transform: translateY(8px);
            transition: all 0.14s cubic-bezier(0.2, 0.0, 0.38, 0.9); /* macOS-style easing */
            will-change: opacity, transform;
        }

        .page-content.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .page-content.switching {
            opacity: 0.3;
            transform: translateY(-4px);
        }

        /* КРИТИЧНО: Никакого transform: scale для canvas! */
        .page-content canvas {
            transform: none !important;
            will-change: auto;
        }

        /* Фиксированные высоты без скролла - обновлено для fixed header */
        .page-body {
            height: calc(100vh - var(--header-h)); /* B1: Dynamic header height */
            overflow: hidden;
            display: grid;
            gap: 16px;
            padding: 16px;
        }

        /* Брейкпоинты для высоты */
        @media (max-height: 1080px) {
            .page-body { 
                height: calc(100vh - var(--header-h));
                gap: 12px;
            }
            .dashboard.density-compact .page-body {
                gap: 8px;
            }
        }

        @media (max-height: 900px) {
            .page-body { 
                height: calc(100vh - var(--header-h));
                gap: 8px;
            }
        }

        /* Горизонтальная прокрутка на узких экранах */
        @media (max-width: 1366px) {
            .page-body {
                overflow-x: auto;
                overflow-y: hidden;
                min-width: 1200px;
                padding: 0 10px;
            }
        }

        /* Лейауты для каждой страницы */
        .page-overview .page-body {
            grid-template-areas: 
                "revenue-trend revenue-trend margins-trend margins-trend"
                "cashflow-chart cashflow-chart variance-chart variance-chart";
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .page-sales .page-body {
            grid-template-areas:
                "branches-chart branches-chart orgs-table orgs-table"
                "managers-table managers-table avg-check avg-check";
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .page-profit .page-body {
            grid-template-areas:
                "margin-branches margin-branches ebitda-bridge ebitda-bridge"
                "opex-categories opex-categories profit-trends profit-trends";
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .page-cash .page-body {
            grid-template-areas:
                "cashflow-bridge cashflow-bridge accounts-table accounts-table"
                "runway-forecast runway-forecast weekly-forecast weekly-forecast";
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .page-ar .page-body {
            grid-template-areas:
                "debtors-table debtors-table aging-chart aging-chart"
                "dso-trends dso-trends reserves-table reserves-table";
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        /* Утилиты */
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .font-bold { font-weight: 600; }
        .text-sm { font-size: 12px; }
        .text-xs { font-size: 10px; }

        /* Настройки для старого WebKit */
        .chart-container {
            -webkit-transform: translateZ(0);
            will-change: auto;
        }

        canvas {
            -webkit-font-smoothing: antialiased;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            /* Prevent any CSS transforms that could blur lines */
            transform: none !important;
        }

        /* Скрыть скроллбары на старом WebKit */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        /* Error boundary styles (B1: Sprint 6) */
        .error-boundary {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
            background: linear-gradient(135deg, #ff6b6b, #e74c3c);
            color: white;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 16px;
            font-size: 14px;
            border-left: 4px solid #c0392b;
        }

        .error-boundary.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border-left-color: #d68910;
        }

        .error-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .error-title {
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .error-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 20px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .error-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .error-details {
            margin: 12px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 100px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .error-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .error-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .error-btn.primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .error-btn.primary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .error-btn.secondary {
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .error-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .error-details.expanded {
            max-height: 200px;
        }

        /* C2: Адаптивная сетка - фиксированные высоты без скролла */
        
        /* 1920×1080 и выше - оптимальное разрешение */
        @media (min-width: 1920px) and (min-height: 1080px) {
            .page-body {
                height: calc(100vh - var(--header-h));
                grid-gap: 20px;
            }
            
            .chart-container {
                min-height: 320px;
            }
            
            .kpi-bar {
                gap: 20px;
            }
            
            .kpi-card {
                min-width: 220px;
                padding: 20px 24px;
            }
        }
        
        /* 1440-высота - стандартное разрешение */
        @media (min-height: 1440px) {
            .page-body {
                height: calc(100vh - var(--header-h));
                grid-gap: 16px;
            }
            
            .chart-container {
                min-height: 280px;
            }
        }
        
        /* 1366×768 - допустимая горизонтальная прокрутка */
        @media (max-width: 1400px) {
            body {
                min-width: 1200px; /* Принудительная горизонтальная прокрутка */
                overflow-x: auto;
            }
            
            .dashboard {
                min-width: 1200px;
            }
            
            .page-body {
                min-width: 1160px; /* Учитываем padding */
                overflow-x: auto;
                overflow-y: hidden;
            }
            
            /* Колонки становятся одноколоночными для очень узких экранов */
            @media (max-width: 1200px) {
                .page-overview .page-body,
                .page-sales .page-body,
                .page-profit .page-body,
                .page-cash .page-body,
                .page-ar .page-body {
                    grid-template-columns: 1fr;
                    grid-template-areas: 
                        "revenue-trend"
                        "margins-trend"
                        "cashflow-chart"
                        "variance-chart";
                    grid-template-rows: repeat(4, minmax(250px, 1fr));
                    height: auto;
                    max-height: calc(100vh - var(--header-h));
                    overflow-y: auto;
                }
                
                .page-sales .page-body {
                    grid-template-areas:
                        "branches-chart"
                        "orgs-table"
                        "managers-table"
                        "avg-check";
                }
                
                .page-profit .page-body {
                    grid-template-areas:
                        "margin-branches"
                        "ebitda-bridge"
                        "opex-categories"
                        "profit-trends";
                }
                
                .page-cash .page-body {
                    grid-template-areas:
                        "cashflow-bridge"
                        "accounts-table"
                        "runway-forecast"
                        "weekly-forecast";
                }
                
                .page-ar .page-body {
                    grid-template-areas:
                        "debtors-table"
                        "aging-analysis"
                        "dso-trends"
                        "reserves-table";
                }
            }
        }

        /* КРИТИЧНО: Никаких CSS-масштабов для canvas */
        @media (max-width: 1366px) {
            canvas {
                transform: none !important;
                scale: none !important;
                zoom: normal !important;
            }
            
            .chart-container canvas {
                width: 100% !important;
                height: 100% !important;
                max-width: none !important;
                max-height: none !important;
            }
        }

        /* Высота для разных экранов */
        @media (max-height: 900px) {
            .page-body {
                height: calc(100vh - var(--header-h));
            }
            
            .chart-container {
                min-height: 200px;
            }
        }
        
        @media (max-height: 768px) {
            .page-body {
                height: calc(100vh - var(--header-h));
                grid-gap: 12px;
            }
            
            .chart-container {
                min-height: 180px;
            }
            
            .kpi-card {
                padding: 12px 16px;
                min-width: 160px;
            }
            
            .dashboard-header {
                padding: 12px;
            }
            
            .dashboard {
                padding-top: var(--header-h); /* B1: Dynamic header height */
            }
        }
    </style>
</head>
<body>
    <!-- CFO Dashboard Bundle - IIFE (Sprint 6) -->
    <div id="dashboard" class="dashboard">
        <!-- Print header (hidden in normal view) -->
        <div class="print-header" style="display: none;">
            <h1>CFO Dashboard</h1>
            <div class="print-info">
                <span id="print-company">ООО «Прогресс»</span> • 
                <span id="print-date"></span> • 
                <span id="print-page-name">Обзор</span>
            </div>
        </div>
        
        <!-- C1: Fixed header - macOS style -->
        <div class="dashboard-header">
            <!-- Фильтры -->
        <div class="filters-header" id="filters-header">
            <div class="filter-group">
                <div class="filter-label">Компания</div>
                <select class="filter-select" id="filter-company">
                    <option value="all">Все компании</option>
                    <option value="progress" selected>ООО Прогресс</option>
                    <option value="alpha">ООО Альфа</option>
                    <option value="beta">ООО Бета</option>
                </select>
            </div>

            <div class="filter-group">
                <div class="filter-label">Обособка</div>
                <select class="filter-select" id="filter-organization">
                    <option value="all">Все обособки</option>
                    <option value="hq" selected>Головной офис</option>
                    <option value="branch1">Филиал №1</option>
                    <option value="branch2">Филиал №2</option>
                </select>
            </div>

            <div class="filter-group">
                <div class="filter-label">Контрагент</div>
                <select class="filter-select" id="filter-counterparty">
                    <option value="all" selected>Все контрагенты</option>
                    <option value="alfa-llc">ООО Альфа</option>
                    <option value="beta-llc">ООО Бета</option>
                    <option value="gamma-llc">ООО Гамма</option>
                </select>
            </div>

            <div class="filter-group">
                <div class="filter-label">Менеджер</div>
                <select class="filter-select" id="filter-manager">
                    <option value="all" selected>Все менеджеры</option>
                    <option value="ivanov">Иванов И.И.</option>
                    <option value="petrov">Петров П.П.</option>
                    <option value="sidorov">Сидоров С.С.</option>
                </select>
            </div>

            <div class="filter-group">
                <div class="filter-label">Период</div>
                <div class="period-presets">
                    <button class="preset-btn" data-preset="today">Сегодня</button>
                    <button class="preset-btn" data-preset="week">Неделя</button>
                    <button class="preset-btn active" data-preset="month">Месяц</button>
                    <button class="preset-btn" data-preset="quarter">Квартал</button>
                    <button class="preset-btn" data-preset="year">Год</button>
                </div>
            </div>

            <div class="filter-group">
                <div class="filter-label">Даты</div>
                <div class="date-range-group">
                    <input type="date" class="filter-input" id="filter-date-from" value="2024-11-01">
                    <span class="date-separator">—</span>
                    <input type="date" class="filter-input" id="filter-date-to" value="2024-11-30">
                </div>
            </div>

            <div class="filter-group">
                <div class="filter-label">Гранулярность</div>
                <select class="filter-select" id="filter-granularity">
                    <option value="daily">Дни</option>
                    <option value="monthly" selected>Месяцы</option>
                    <option value="quarterly">Кварталы</option>
                    <option value="yearly">Годы</option>
                </select>
            </div>

            <div class="filter-group">
                <div class="filter-label">Показатели</div>
                <div class="filter-checkboxes">
                    <div class="checkbox-item">
                        <input type="checkbox" id="show-fact" checked>
                        <label for="show-fact">Факт</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="show-plan" checked>
                        <label for="show-plan">План</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="show-prev-year" checked>
                        <label for="show-prev-year">ПГ</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="show-forecast" checked>
                        <label for="show-forecast">Прогноз</label>
                    </div>
                </div>
            </div>

            <div class="filter-group">
                <div class="filter-label">Режим</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="toggle-percentage">
                    <span class="toggle-slider"></span>
                </label>
                <div class="filter-label" style="font-size: 10px; margin-top: 4px;">
                    <span id="toggle-mode-label">Абсолют</span>
                </div>
            </div>

            <div class="filter-group">
                <div class="filter-label">Плотность</div>
                <select class="filter-select" id="density-selector">
                    <option value="comfort" selected>Комфорт</option>
                    <option value="compact">Компакт</option>
                </select>
            </div>
        </div>

            <!-- Навигация по страницам (Sprint 4) -->
        <nav class="page-navigation" role="tablist" aria-label="Разделы дашборда">
            <div class="export-controls">
                <button class="export-page-btn" title="Экспорт текущей страницы в PNG">
                    📸 Страница
                </button>
                <button class="export-all-btn" title="Экспорт всех страниц в PNG">
                    📁 Все
                </button>
                <button class="batch-export-btn" title="E2: Batch-экспорт с манифестом">
                    📦 Batch
                </button>
            </div>
            <div class="navigation-center">
                <div class="segmented-control">
                    <button class="segment-tab active" 
                            role="tab" 
                            aria-selected="true" 
                            aria-current="page"
                            aria-controls="page-overview"
                            data-page="overview"
                            tabindex="0">
                        Обзор
                    </button>
                    <button class="segment-tab" 
                            role="tab" 
                            aria-selected="false"
                            aria-controls="page-sales" 
                            data-page="sales"
                            tabindex="-1">
                        Продажи
                    </button>
                    <button class="segment-tab" 
                            role="tab" 
                            aria-selected="false"
                            aria-controls="page-profit" 
                            data-page="profit"
                            tabindex="-1">
                        Прибыльность
                    </button>
                    <button class="segment-tab" 
                            role="tab" 
                            aria-selected="false"
                            aria-controls="page-cash" 
                            data-page="cash"
                            tabindex="-1">
                        Ликвидность
                    </button>
                    <button class="segment-tab" 
                            role="tab" 
                            aria-selected="false"
                            aria-controls="page-ar" 
                            data-page="ar"
                            tabindex="-1">
                        Дебиторка
                    </button>
                </div>
            </div>
            <div style="min-width: 120px;"></div> <!-- Spacer для симметрии -->
        </nav>

        <!-- Топовая полоса KPI -->
        <div class="kpi-bar">
            <div class="kpi-card" id="revenue-kpi">
                <div class="kpi-title">Выручка, млн ₽</div>
                <div class="kpi-value" id="revenue-value">125.6</div>
                <div class="kpi-change positive" id="revenue-change">+8.5% MoM</div>
            </div>
            <div class="kpi-card" id="ebitda-kpi">
                <div class="kpi-title">EBITDA, млн ₽</div>
                <div class="kpi-value" id="ebitda-value">28.9</div>
                <div class="kpi-change positive" id="ebitda-change">+23.2% YoY</div>
            </div>
            <div class="kpi-card" id="ocf-kpi">
                <div class="kpi-title">OCF, млн ₽</div>
                <div class="kpi-value" id="ocf-value">31.2</div>
                <div class="kpi-change neutral" id="ocf-change">—</div>
            </div>
            <div class="kpi-card" id="cash-kpi">
                <div class="kpi-title">Cash на конец, млн ₽</div>
                <div class="kpi-value" id="cash-value">45.6</div>
                <div class="kpi-change warning" id="cash-runway">4.2 мес</div>
            </div>
            <div class="kpi-card dropdown" id="margins-kpi">
                <div class="kpi-title">
                    Маржинальность, %
                    <select id="margin-selector" class="margin-selector">
                        <option value="gross">Валовая</option>
                        <option value="ebitda" selected>EBITDA</option>
                        <option value="net">Чистая</option>
                    </select>
                </div>
                <div class="kpi-value" id="margin-value">23.1</div>
                <div class="kpi-change positive" id="margin-change">+0.2 п.п.</div>
            </div>
        </div>
        </div>

        <!-- Print controls (moved outside fixed header) -->
        <div class="print-controls" style="position: fixed; top: 20px; right: 20px; z-index: 1001;">
            <button class="toggle-btn print-page-btn">Печать страницы</button>
            <button class="toggle-btn print-all-btn">Печать все</button>
        </div>

        <!-- D1: Баннер рекомендаций -->
        <div id="recommendations-banner" class="recommendations-banner">
            <div class="banner-header">
                <div class="banner-title">
                    💡 Рекомендации
                </div>
                <button class="banner-close">&times;</button>
            </div>
            <div class="banner-content" id="recommendation-text">
                <!-- Текст рекомендации будет вставлен динамически -->
            </div>
            <div class="banner-actions">
                <button class="banner-btn primary" id="recommendation-details">Подробнее</button>
                <button class="banner-btn">Скрыть на сегодня</button>
            </div>
        </div>

        <!-- Страницы дашборда (Sprint 4) -->
        <div id="page-overview" class="page-content active page-overview" role="tabpanel" aria-labelledby="tab-overview">
            <div class="page-body">
                <!-- Динамика выручки -->
            <div class="chart-container" id="revenue-trend-container">
                <div class="chart-header">
                    <h3>Динамика выручки, млн ₽</h3>
                    <div class="chart-controls">
                        <button class="toggle-btn active" data-series="fact">Факт</button>
                        <button class="toggle-btn active" data-series="plan">План</button>
                        <button class="toggle-btn active" data-series="prevYear">ПГ</button>
                        <button class="toggle-btn active" data-series="forecast">Прогноз</button>
                    </div>
                </div>
                <div class="chart-body">
                    <canvas id="revenue-trend-chart"></canvas>
                </div>
            </div>

            <!-- Маржинальность -->
            <div class="chart-container" id="margins-trend-container">
                <div class="chart-header">
                    <h3>Маржинальность, %</h3>
                    <div class="chart-controls">
                        <button class="toggle-btn active" data-margin="gross">Валовая</button>
                        <button class="toggle-btn active" data-margin="ebitda">EBITDA</button>
                        <button class="toggle-btn active" data-margin="net">Чистая</button>
                    </div>
                </div>
                <div class="chart-body">
                    <canvas id="margins-trend-chart"></canvas>
                </div>
            </div>

            <!-- Cash Flow Waterfall -->
            <div class="chart-container" id="cashflow-container">
                <div class="chart-header">
                    <h3>Движение ДС (Waterfall), млн ₽</h3>
                </div>
                <div class="chart-body">
                    <canvas id="cashflow-chart"></canvas>
                </div>
            </div>

            <!-- Variance Waterfall -->
            <div class="chart-container" id="variance-container">
                <div class="chart-header">
                    <h3>План vs Факт (Variance), млн ₽</h3>
                </div>
                <div class="chart-body">
                    <canvas id="variance-chart"></canvas>
                </div>
            </div>

            <!-- Выручка по направлениям -->
            <div class="chart-container" id="revenue-branches-container">
                <div class="chart-header">
                    <h3>Выручка по направлениям</h3>
                    <div class="chart-controls">
                        <button class="toggle-btn active" data-mode="absolute">Абсолютные</button>
                        <button class="toggle-btn" data-mode="percent">100%</button>
                    </div>
                </div>
                <div class="chart-body">
                    <canvas id="revenue-branches-chart"></canvas>
                </div>
            </div>

            <!-- Дебиторка -->
            <div class="chart-container" id="debtors-container">
                <div class="chart-header">
                    <h3>Дебиторка + просрочка</h3>
                </div>
                <div class="chart-body">
                    <div class="debtors-summary">
                        <div class="aging-buckets">
                            <div class="bucket bucket-0-30">0-30: 8.2 млн</div>
                            <div class="bucket bucket-31-60">31-60: 6.8 млн</div>
                            <div class="bucket bucket-61-90">61-90: 2.4 млн</div>
                            <div class="bucket bucket-90">90+: 3.1 млн</div>
                        </div>
                        <div class="dso-indicator">DSO: <span id="dso-value">47</span> дн.</div>
                    </div>
                    <div class="debtors-table" id="debtors-table"></div>
                </div>
            </div>

            <!-- Финансовые коэффициенты -->
            <div class="chart-container" id="coefficients-container">
                <div class="chart-header">
                    <h3>Финансовые коэффициенты</h3>
                </div>
                <div class="chart-body">
                    <div class="coefficients-grid" id="coefficients-grid"></div>
                </div>
            </div>

            <!-- Остатки по счетам + Cash Runway -->
            <div class="chart-container" id="cash-accounts-container">
                <div class="chart-header">
                    <h3>Остатки по счетам + Runway</h3>
                </div>
                <div class="chart-body">
                    <div class="cash-summary">
                        <div class="runway-indicator">
                            Cash Runway: <span id="runway-months">4.2</span> мес.
                        </div>
                    </div>
                    <div class="accounts-table" id="accounts-table"></div>
                </div>
            </div>
            </div>
        </div>

        <!-- Страница Продажи -->
        <div id="page-sales" class="page-content page-sales" role="tabpanel" aria-labelledby="tab-sales">
            <div class="page-body">
                <!-- Выручка по направлениям -->
                <div class="chart-container" id="branches-chart-sales" style="grid-area: branches-chart;">
                    <div class="chart-header">
                        <h3>Выручка по направлениям</h3>
                        <div class="chart-controls">
                            <button class="toggle-btn active" data-mode="absolute">Абсолютные</button>
                            <button class="toggle-btn" data-mode="percent">100%</button>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="branches-sales-chart"></canvas>
                    </div>
                </div>

                <!-- ТОП организаций -->
                <div class="chart-container" id="orgs-table-sales" style="grid-area: orgs-table;">
                    <div class="chart-header">
                        <h3>ТОП организаций</h3>
                    </div>
                    <div class="chart-body">
                        <div class="organizations-table" id="organizations-sales-table"></div>
                    </div>
                </div>

                <!-- ТОП менеджеров -->
                <div class="chart-container" id="managers-table-sales" style="grid-area: managers-table;">
                    <div class="chart-header">
                        <h3>ТОП менеджеров</h3>
                    </div>
                    <div class="chart-body">
                        <div class="managers-table" id="managers-sales-table"></div>
                    </div>
                </div>

                <!-- Средний чек -->
                <div class="chart-container" id="avg-check-sales" style="grid-area: avg-check;">
                    <div class="chart-header">
                        <h3>Средний чек</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="avg-check-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Страница Прибыльность -->
        <div id="page-profit" class="page-content page-profit" role="tabpanel" aria-labelledby="tab-profit">
            <div class="page-body">
                <!-- Маржи по направлениям -->
                <div class="chart-container" id="margin-branches-profit" style="grid-area: margin-branches;">
                    <div class="chart-header">
                        <h3>Маржинальность по направлениям</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="margin-branches-chart"></canvas>
                    </div>
                </div>

                <!-- EBITDA Bridge -->
                <div class="chart-container" id="ebitda-bridge-profit" style="grid-area: ebitda-bridge;">
                    <div class="chart-header">
                        <h3>EBITDA-мост по драйверам</h3>
                        <div class="chart-controls">
                            <button class="toggle-btn active" id="ebitda-values-btn">Млн ₽</button>
                            <button class="toggle-btn" id="ebitda-margin-btn">% маржи</button>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="ebitda-bridge-chart"></canvas>
                        <div class="drivers-legend">
                            <div class="legend-item">
                                <span class="legend-color price"></span>
                                <span>Price - Цена</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color volume"></span>
                                <span>Volume - Объём</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color mix"></span>
                                <span>Mix - Микс</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color fx"></span>
                                <span>FX - Курс</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color cogs"></span>
                                <span>COGS - Себест.</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color opex"></span>
                                <span>OPEX - Операц.</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- OPEX по категориям -->
                <div class="chart-container" id="opex-categories-profit" style="grid-area: opex-categories;">
                    <div class="chart-header">
                        <h3>OPEX по категориям</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="opex-categories-chart"></canvas>
                    </div>
                </div>

                <!-- Тренды прибыльности -->
                <div class="chart-container" id="profit-trends-profit" style="grid-area: profit-trends;">
                    <div class="chart-header">
                        <h3>Тренды прибыльности</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="profit-trends-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Страница Ликвидность & Cash -->
        <div id="page-cash" class="page-content page-cash" role="tabpanel" aria-labelledby="tab-cash">
            <div class="page-body">
                <!-- ДДС-мост -->
                <div class="chart-container" id="cashflow-bridge-cash" style="grid-area: cashflow-bridge;">
                    <div class="chart-header">
                        <h3>Движение ДС (Bridge)</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="cashflow-bridge-chart"></canvas>
                    </div>
                </div>

                <!-- Остатки по счетам -->
                <div class="chart-container" id="accounts-table-cash" style="grid-area: accounts-table;">
                    <div class="chart-header">
                        <h3>Остатки по счетам</h3>
                    </div>
                    <div class="chart-body">
                        <div class="accounts-detailed-table" id="accounts-detailed-table"></div>
                    </div>
                </div>

                <!-- Cash Runway -->
                <div class="chart-container" id="runway-forecast-cash" style="grid-area: runway-forecast;">
                    <div class="chart-header">
                        <h3>Cash Runway</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="runway-forecast-chart"></canvas>
                    </div>
                </div>

                <!-- 4-8 недельный прогноз -->
                <div class="chart-container" id="weekly-forecast-cash" style="grid-area: weekly-forecast;">
                    <div class="chart-header">
                        <h3>Кэш-прогноз 4–8 недель</h3>
                        <div class="scenario-controls">
                            <button class="scenario-btn active" data-scenario="base">База</button>
                            <button class="scenario-btn" data-scenario="optimistic">Опт.</button>
                            <button class="scenario-btn" data-scenario="pessimistic">Песс.</button>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="weekly-forecast-chart"></canvas>
                        <div class="forecast-details">
                            <div class="forecast-columns">
                                <div class="forecast-column">
                                    <h4>Инкассации</h4>
                                    <div id="forecast-collections"></div>
                                </div>
                                <div class="forecast-column">
                                    <h4>Платежи</h4>
                                    <div id="forecast-payments"></div>
                                </div>
                                <div class="forecast-column">
                                    <h4>Cash Balance</h4>
                                    <div id="forecast-balance"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Страница Дебиторка & Риск -->
        <div id="page-ar" class="page-content page-ar" role="tabpanel" aria-labelledby="tab-ar">
            <div class="page-body">
                <!-- Таблица дебиторки -->
                <div class="chart-container" id="debtors-table-ar" style="grid-area: debtors-table;">
                    <div class="chart-header">
                        <h3>Дебиторка с бакетами</h3>
                    </div>
                    <div class="chart-body">
                        <div class="debtors-detailed-table" id="debtors-detailed-table"></div>
                    </div>
                </div>

                <!-- Aging Chart -->
                <div class="chart-container" id="aging-chart-ar" style="grid-area: aging-chart;">
                    <div class="chart-header">
                        <h3>Aging Analysis</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="aging-analysis-chart"></canvas>
                    </div>
                </div>

                <!-- DSO тренды -->
                <div class="chart-container" id="dso-trends-ar" style="grid-area: dso-trends;">
                    <div class="chart-header">
                        <h3>DSO / CCC тренды</h3>
                    </div>
                    <div class="chart-body">
                        <canvas id="dso-trends-chart"></canvas>
                    </div>
                </div>

                <!-- Резервы -->
                <div class="chart-container" id="reserves-table-ar" style="grid-area: reserves-table;">
                    <div class="chart-header">
                        <h3>Резервы по сомнительным долгам</h3>
                    </div>
                    <div class="chart-body">
                        <div class="reserves-table" id="reserves-table"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Колокольчик алертов -->
        <div class="alerts-bell" id="alerts-bell">
            <svg class="alerts-bell-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-5-5-5 5h5zm0 0v-7a6 6 0 11-6 6 6 6 0 016-6v7z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.73 21c0 .28-.21.5-.47.5h-2.52c-.26 0-.47-.22-.47-.5"/>
            </svg>
            <div class="alerts-counter" id="alerts-counter" style="display: none;">0</div>
        </div>

        <!-- Панель алертов -->
        <div class="alerts-panel" id="alerts-panel">
            <div class="alerts-header">
                <div class="alerts-title">Алерты</div>
                <div class="alerts-filter">
                    <button class="severity-filter-btn active" data-severity="all">Все</button>
                    <button class="severity-filter-btn" data-severity="critical">Critical</button>
                    <button class="severity-filter-btn" data-severity="high">High</button>
                    <button class="severity-filter-btn" data-severity="medium">Medium</button>
                </div>
            </div>
            <div class="alerts-body" id="alerts-body">
                <div class="alerts-empty">
                    <svg class="alerts-empty-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <div>Нет активных алертов</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Подключение оффлайн бандла -->
    <script src="./dashboard.bundle.js"></script>
    
    <!-- Основной JS -->
    <script>
(function() {
    'use strict';
    
    // Благородная дорогая палитра
    const IBCS_COLORS = {
        fact: '#2c3e50',        // Глубокий сине-серый (элегантная замена черного)
        plan: 'transparent',
        planBorder: '#34495e',  // Более темный сине-серый для контуров
        prevYear: '#95a5a6',    // Серебристый серый
        forecast: '#3498db',    // Королевский синий
        positive: '#27ae60',    // Изумрудно-зеленый
        negative: '#e74c3c',    // Благородный красный
        warning: '#f39c12',     // Янтарный
        neutral: '#7f8c8d'      // Платиновый серый
    };

    // Removed duplicate ensureHiDPI - using CFODashboard.ensureHiDPI from bundle
    
    // Crisp Plugin for pixel-perfect lines
    const CrispPlugin = {
        id:'crisp',
        beforeDatasetsDraw(c){ const {ctx} = c; ctx.save(); ctx.translate(0.5,0.5); },
        afterDatasetsDraw(c){ c.ctx.restore(); }
    };

    // Глобальное состояние
    let dashboardData = null;
    let charts = {};
    
    // Use formatters from CFODashboard bundle (Sprint 6)
    const formatters = CFODashboard.formatters;

    // Use utilities from CFODashboard bundle (Sprint 6) 
    const ensureHiDPI = CFODashboard.ensureHiDPI;
    const createLineChart = CFODashboard.createLineChart;
    const createWaterfallChart = CFODashboard.createWaterfallChart;
    const createHorizontalBarChart = CFODashboard.createHorizontalBarChart;
    const createVarianceChart = CFODashboard.createVarianceChart;
    const createDebtorsTable = CFODashboard.createDebtorsTable;
    const createAccountsTable = CFODashboard.createAccountsTable;
    const updateWaterfallChart = CFODashboard.updateWaterfallChart;

    // Legacy function wrapper for compatibility
    function createLineChartOld(canvasId, data, yAxisFormatter = formatters.millions) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        const datasets = [];
        
        if (data.fact) {
            datasets.push({
                label: 'Факт',
                data: data.fact,
                borderColor: IBCS_COLORS.fact,
                backgroundColor: IBCS_COLORS.fact,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                borderWidth: 1,
                borderJoinStyle: 'miter',
                borderCapStyle: 'butt',
                cubicInterpolationMode: 'monotone',
                spanGaps: true
            });
        }
        
        if (data.plan) {
            datasets.push({
                label: 'План',
                data: data.plan,
                borderColor: IBCS_COLORS.planBorder,
                backgroundColor: IBCS_COLORS.plan,
                fill: false,
                borderDash: [0],
                tension: 0.1,
                pointRadius: 0,
                borderWidth: 1,
                borderJoinStyle: 'miter',
                borderCapStyle: 'butt',
                cubicInterpolationMode: 'monotone',
                spanGaps: true,
                pointBackgroundColor: IBCS_COLORS.plan,
                pointBorderColor: IBCS_COLORS.planBorder
            });
        }
        
        if (data.prevYear) {
            datasets.push({
                label: 'Прошлый год',
                data: data.prevYear,
                borderColor: IBCS_COLORS.prevYear,
                backgroundColor: IBCS_COLORS.prevYear,
                fill: false,
                tension: 0.1,
                pointRadius: 0,
                borderWidth: 1,
                borderJoinStyle: 'miter',
                borderCapStyle: 'butt',
                cubicInterpolationMode: 'monotone',
                spanGaps: true
            });
        }
        
        if (data.forecast) {
            const forecastData = new Array(data.fact.length - data.forecast.length).fill(null)
                .concat(data.forecast);
            datasets.push({
                label: 'Прогноз',
                data: forecastData,
                borderColor: IBCS_COLORS.forecast,
                backgroundColor: IBCS_COLORS.forecast,
                fill: false,
                borderDash: [5, 5],
                tension: 0.1,
                pointRadius: 0,
                borderWidth: 1,
                borderJoinStyle: 'miter',
                borderCapStyle: 'butt',
                cubicInterpolationMode: 'monotone',
                spanGaps: true
            });
        }

        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.dates,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                parsing: false,
                normalized: true,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${yAxisFormatter(context.parsed.y)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        ticks: {
                            callback: yAxisFormatter
                        }
                    }
                },
                onResize: function(chart) {
                    ensureHiDPI(chart.canvas);
                }
            },
            plugins: [CrispPlugin]
        });
        
        // Initialize HiDPI on creation
        ensureHiDPI(ctx.canvas);
        
        return chart;
    }

    // Создание горизонтального бара для направлений
    function createHorizontalBarChart(canvasId, data, mode = 'absolute') {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Сортировка по убыванию
        const sortedData = [...data].sort((a, b) => b.revenue - a.revenue);
        
        const chartData = {
            labels: sortedData.map(d => d.name),
            datasets: [{
                label: 'Выручка',
                data: mode === 'absolute' ? 
                    sortedData.map(d => d.revenue) : 
                    sortedData.map(d => d.share),
                backgroundColor: IBCS_COLORS.fact,
                borderColor: IBCS_COLORS.fact,
                borderWidth: 1
            }]
        };

        return new Chart(ctx, {
            type: 'bar',
            data: chartData,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const item = sortedData[context.dataIndex];
                                return [
                                    `Выручка: ${formatters.currency(item.revenue)}`,
                                    `Прибыль: ${formatters.currency(item.profit)}`,
                                    `Маржа: ${formatters.percent(item.margin)}`,
                                    `Доля: ${formatters.percent(item.share)}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                return mode === 'absolute' ? 
                                    formatters.millions(value) : 
                                    formatters.percent(value);
                            }
                        }
                    }
                }
            }
        });
    }

    // Enhanced Variance Waterfall: План vs Факт
    function createVarianceChart(canvasId, data) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Создаём waterfall структуру: План (база) → отклонения → Факт
        const plannedTotal = data.find(d => d.driver === 'EBITDA')?.plan || 0;
        const factTotal = data.find(d => d.driver === 'EBITDA')?.fact || 0;
        
        // Строим waterfall с накоплением
        const waterfallData = [];
        const labels = [];
        const colors = [];
        const tooltipData = [];
        
        // Стартовая точка - План
        waterfallData.push(plannedTotal);
        labels.push('План EBITDA');
        colors.push(IBCS_COLORS.plan);
        tooltipData.push({ type: 'plan', value: plannedTotal, fact: null, variance: null });
        
        // Отклонения по драйверам (кроме итогового EBITDA)
        let runningTotal = plannedTotal;
        data.forEach(item => {
            if (item.driver !== 'EBITDA') {
                waterfallData.push(item.variance);
                labels.push('Δ ' + item.driver);
                colors.push(item.variance >= 0 ? IBCS_COLORS.positive : IBCS_COLORS.negative);
                tooltipData.push({ 
                    type: 'variance', 
                    driver: item.driver,
                    value: item.variance, 
                    fact: item.fact, 
                    plan: item.plan,
                    variancePercent: item.variancePercent 
                });
                runningTotal += item.variance;
            }
        });
        
        // Итоговый факт
        waterfallData.push(factTotal);
        labels.push('Факт EBITDA');
        colors.push(IBCS_COLORS.fact);
        tooltipData.push({ type: 'fact', value: factTotal, plan: plannedTotal, variance: factTotal - plannedTotal });
        
        const chartData = {
            labels: labels,
            datasets: [{
                label: 'План vs Факт',
                data: waterfallData,
                backgroundColor: function(ctx) {
                    return colors[ctx.dataIndex];
                },
                borderColor: function(ctx) {
                    const dataType = tooltipData[ctx.dataIndex]?.type;
                    if (dataType === 'plan') return IBCS_COLORS.planBorder;
                    if (dataType === 'fact') return IBCS_COLORS.fact;
                    return IBCS_COLORS.fact;
                },
                borderWidth: function(ctx) {
                    const dataType = tooltipData[ctx.dataIndex]?.type;
                    return dataType === 'plan' ? 2 : 1;
                }
            }]
        };

        const chart = new Chart(ctx, {
            type: 'bar',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                parsing: false,
                normalized: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            title: function(context) {
                                return context[0].label;
                            },
                            label: function(context) {
                                const item = tooltipData[context.dataIndex];
                                if (!item) return '';
                                
                                if (item.type === 'plan') {
                                    return 'План: ' + formatters.currency(item.value);
                                } else if (item.type === 'fact') {
                                    return [
                                        'Факт: ' + formatters.currency(item.value),
                                        'План: ' + formatters.currency(item.plan),
                                        'Отклонение: ' + formatters.currency(item.variance) + 
                                        ' (' + ((item.variance / item.plan) * 100).toFixed(1) + '%)'
                                    ];
                                } else if (item.type === 'variance') {
                                    return [
                                        'Факт: ' + formatters.currency(item.fact),
                                        'План: ' + formatters.currency(item.plan),
                                        'Δ абсолют: ' + formatters.currency(item.value),
                                        'Δ %: ' + item.variancePercent.toFixed(1) + '%'
                                    ];
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'млн ₽'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatters.millions(value);
                            }
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: 45,
                            minRotation: 0
                        }
                    }
                },
                onResize: function(chart) {
                    ensureHiDPI(chart.canvas);
                }
            },
            plugins: [{
                id: 'varianceConnectors',
                beforeDraw: function(chart) {
                    const ctx = chart.ctx;
                    const meta = chart.getDatasetMeta(0);
                    
                    ctx.save();
                    ctx.strokeStyle = '#d1d5db';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    
                    let currentTotal = plannedTotal;
                    
                    // Соединительные линии для waterfall
                    for (let i = 1; i < meta.data.length - 1; i++) {
                        const currentBar = meta.data[i];
                        const prevBar = meta.data[i - 1];
                        
                        if (currentBar && prevBar) {
                            const variance = waterfallData[i];
                            
                            ctx.beginPath();
                            if (variance >= 0) {
                                // Положительное отклонение
                                ctx.moveTo(prevBar.x + prevBar.width/2, prevBar.y);
                                ctx.lineTo(currentBar.x - currentBar.width/2, currentBar.y + currentBar.height);
                            } else {
                                // Отрицательное отклонение
                                ctx.moveTo(prevBar.x + prevBar.width/2, prevBar.y);
                                ctx.lineTo(currentBar.x - currentBar.width/2, currentBar.y);
                            }
                            ctx.stroke();
                            
                            currentTotal += variance;
                        }
                    }
                    
                    // Соединение последнего отклонения с фактом
                    if (meta.data.length > 2) {
                        const lastBar = meta.data[meta.data.length - 1];
                        const prevBar = meta.data[meta.data.length - 2];
                        
                        if (lastBar && prevBar) {
                            ctx.beginPath();
                            ctx.moveTo(prevBar.x + prevBar.width/2, prevBar.y);
                            ctx.lineTo(lastBar.x - lastBar.width/2, lastBar.y + lastBar.height);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.restore();
                }
            }]
        });
        
        // Initialize HiDPI on creation
        ensureHiDPI(ctx.canvas);
        
        // Проверка корректности суммы
        chart._varianceCheck = function() {
            const calculatedFact = plannedTotal + data.filter(d => d.driver !== 'EBITDA')
                .reduce((sum, item) => sum + item.variance, 0);
            return {
                planned: plannedTotal,
                calculated: calculatedFact,
                actual: factTotal,
                sumsMatch: Math.abs(calculatedFact - factTotal) < 0.01
            };
        };
        
        return chart;
    }

    // Enhanced Waterfall ДДС + линия остатка
    function createWaterfallChart(canvasId, data, title) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Расчет накопительных значений
        const values = [data.opening, ...data.ocf, ...data.icf, ...data.fcf, data.closing];
        const cumulative = [data.opening];
        
        for (let i = 1; i < values.length - 1; i++) {
            cumulative.push(cumulative[i-1] + values[i]);
        }
        cumulative.push(data.closing);
        
        // Данные для столбцов
        const waterfallData = values.map((value, index) => {
            if (index === 0 || index === values.length - 1) {
                // Opening и Closing - абсолютные значения
                return value;
            } else {
                // Промежуточные - относительные
                return value;
            }
        });
        
        const chartData = {
            labels: data.labels,
            datasets: [
                {
                    label: 'Движение ДС',
                    type: 'bar',
                    data: waterfallData,
                    backgroundColor: function(ctx) {
                        const index = ctx.dataIndex;
                        const value = ctx.parsed.y;
                        
                        if (index === 0 || index === ctx.dataset.data.length - 1) {
                            return IBCS_COLORS.fact; // Opening/Closing
                        }
                        return value >= 0 ? IBCS_COLORS.positive : IBCS_COLORS.negative;
                    },
                    borderColor: IBCS_COLORS.fact,
                    borderWidth: 1,
                    yAxisID: 'y'
                },
                {
                    label: 'Остаток',
                    type: 'line',
                    data: cumulative,
                    borderColor: IBCS_COLORS.forecast,
                    backgroundColor: IBCS_COLORS.forecast,
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 4,
                    pointBackgroundColor: IBCS_COLORS.forecast,
                    yAxisID: 'y1'
                }
            ]
        };

        const chart = new Chart(ctx, {
            type: 'bar',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false, // Отключаем анимацию
                parsing: false,
                normalized: true,
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: {
                            filter: function(item) {
                                return item.text !== 'Движение ДС' || item.datasetIndex === 0;
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.datasetIndex === 0) {
                                    return context.dataset.label + ': ' + formatters.currency(context.parsed.y);
                                } else {
                                    return 'Остаток: ' + formatters.currency(context.parsed.y);
                                }
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Движение, млн ₽'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatters.millions(value);
                            }
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Остаток, млн ₽'
                        },
                        grid: {
                            drawOnChartArea: false,
                        },
                        ticks: {
                            callback: function(value) {
                                return formatters.millions(value);
                            }
                        }
                    }
                },
                onResize: function(chart) {
                    ensureHiDPI(chart.canvas);
                }
            },
            plugins: [{
                id: 'waterfallConnectors',
                beforeDraw: function(chart) {
                    const ctx = chart.ctx;
                    const meta = chart.getDatasetMeta(0);
                    
                    ctx.save();
                    ctx.strokeStyle = '#d1d5db';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    
                    let runningTotal = data.opening;
                    
                    for (let i = 1; i < meta.data.length - 1; i++) {
                        const currentBar = meta.data[i];
                        const prevBar = meta.data[i - 1];
                        
                        if (currentBar && prevBar) {
                            const value = waterfallData[i];
                            
                            // Соединяющая линия
                            ctx.beginPath();
                            
                            if (value >= 0) {
                                // Положительное - от верха предыдущего к низу текущего
                                ctx.moveTo(prevBar.x + prevBar.width/2, prevBar.y);
                                ctx.lineTo(currentBar.x - currentBar.width/2, currentBar.y + currentBar.height);
                            } else {
                                // Отрицательное - от верха предыдущего к верху текущего
                                ctx.moveTo(prevBar.x + prevBar.width/2, prevBar.y);
                                ctx.lineTo(currentBar.x - currentBar.width/2, currentBar.y);
                            }
                            
                            ctx.stroke();
                            runningTotal += value;
                        }
                    }
                    
                    ctx.restore();
                }
            }]
        });
        
        // Initialize HiDPI on creation
        ensureHiDPI(ctx.canvas);
        
        // Добавляем debug функцию
        chart._waterfallDebug = function() {
            return {
                values: values,
                cumulative: cumulative,
                calculation: {
                    opening: data.opening,
                    flows: [data.ocf, data.icf, data.fcf].flat(),
                    closing: data.closing,
                    check: cumulative[cumulative.length - 1] === data.closing
                }
            };
        };
        
        return chart;
    }

    // Создание спарклайна через canvas с HiDPI поддержкой
    function createSparkline(canvasId, data, width = 100, height = 30) {
        const canvas = document.getElementById(canvasId);
        if (!canvas || !data || data.length < 2) return;
        
        canvas.width = width;
        canvas.height = height;
        
        // Apply HiDPI scaling
        ensureHiDPI(canvas);
        
        // Use bundled sparkline function
        Chart.drawSparkline(canvas, data, {
            color: IBCS_COLORS.fact,
            lineWidth: 1.5
        });
    }

    // Обновление KPI карточек
    function updateKPICards(data) {
        const elements = {
            'revenue-value': formatters.millions(data.kpi.revenue.current),
            'revenue-change': `${data.kpi.revenue.momChange >= 0 ? '+' : ''}${data.kpi.revenue.momChange.toFixed(1)}% MoM`,
            'ebitda-value': formatters.millions(data.kpi.ebitda),
            'ebitda-change': `${data.kpi.revenue.yoyChange >= 0 ? '+' : ''}${data.kpi.revenue.yoyChange.toFixed(1)}% YoY`,
            'ocf-value': formatters.millions(data.kpi.ocf),
            'cash-value': formatters.millions(data.kpi.cashEnd),
            'cash-runway': `${data.kpi.cashRunwayMonths.toFixed(1)} мес`,
            'margin-value': formatters.percent(data.kpi.margins.ebitda)
        };
        
        Object.entries(elements).forEach(([id, value]) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
        });
    }

    // Enhanced дебиторка: бакеты + DSO + автосортировка
    function createDebtorsTable(data) {
        const container = document.getElementById('debtors-table');
        if (!container) return;
        
        // Автобакетизация если не указана
        const processedData = data.map(debtor => {
            let bucket = debtor.bucket;
            if (!bucket) {
                const days = debtor.daysOverdue || 0;
                if (days <= 30) bucket = '0-30';
                else if (days <= 60) bucket = '31-60';
                else if (days <= 90) bucket = '61-90';
                else bucket = '90+';
            }
            
            // SLA расчёт
            let slaStatus = 'good';
            const days = debtor.daysOverdue || 0;
            if (days > 90) slaStatus = 'critical';
            else if (days > 60) slaStatus = 'warning';
            else if (days > 30) slaStatus = 'caution';
            
            return {
                ...debtor,
                bucket,
                slaStatus,
                utilizationPct: debtor.creditLimit ? (debtor.amount / debtor.creditLimit * 100) : 0
            };
        });
        
        // Сортировка по убыванию суммы
        const sortedData = processedData.sort((a, b) => b.amount - a.amount);
        
        // Расчёт DSO
        const totalAR = sortedData.reduce((sum, d) => sum + d.amount, 0);
        const avgDailySales = dashboardData?.kpi?.revenue?.current ? 
            dashboardData.kpi.revenue.current / 365 : 
            totalAR / 45; // fallback estimation
        const calculatedDSO = totalAR / avgDailySales;
        
        // Обновляем DSO индикатор
        const dsoElement = document.getElementById('dso-value');
        if (dsoElement) {
            dsoElement.textContent = Math.round(calculatedDSO);
            dsoElement.title = 'DSO = Дебиторка / (Выручка / 365)';
        }
        
        // Создание расширенной таблицы
        const table = document.createElement('table');
        table.className = 'debtors-table';
        
        const header = table.createTHead();
        const headerRow = header.insertRow();
        const columns = [
            { key: 'name', label: 'Контрагент', sortable: true },
            { key: 'amount', label: 'Сумма', sortable: true },
            { key: 'daysOverdue', label: 'Просрочка', sortable: true },
            { key: 'bucket', label: 'Бакет', sortable: false },
            { key: 'expectedDate', label: 'Ожид. дата', sortable: true },
            { key: 'creditLimit', label: 'Лимит', sortable: true },
            { key: 'utilization', label: 'Использование', sortable: false }
        ];
        
        columns.forEach(col => {
            const th = document.createElement('th');
            th.textContent = col.label;
            if (col.sortable) {
                th.style.cursor = 'pointer';
                th.title = 'Кликните для сортировки';
                th.addEventListener('click', () => sortDebtorsTable(col.key));
            }
            headerRow.appendChild(th);
        });
        
        const tbody = table.createTBody();
        
        // Рендер строк с улучшенным форматированием
        sortedData.forEach((debtor, index) => {
            const row = tbody.insertRow();
            row.className = `sla-${debtor.slaStatus}`;
            
            const expectedDate = debtor.expectedDate ? 
                new Date(debtor.expectedDate).toLocaleDateString('ru-RU') : '—';
            
            const limitText = debtor.creditLimit ? 
                formatters.currency(debtor.creditLimit) : '—';
                
            const utilizationText = debtor.creditLimit ? 
                `${debtor.utilizationPct.toFixed(0)}%` : '—';
            
            const bucketClass = debtor.bucket.replace(/[^a-z0-9]/gi, '-');
            
            row.innerHTML = `
                <td class="debtor-name" title="${debtor.manager || ''}">${debtor.name}</td>
                <td class="amount">${formatters.currency(debtor.amount)}</td>
                <td class="overdue ${debtor.daysOverdue > 0 ? 'has-overdue' : ''}">${debtor.daysOverdue || 0} дн.</td>
                <td class="bucket-cell">
                    <span class="bucket bucket-${bucketClass}" title="Возрастной бакет">${debtor.bucket}</span>
                </td>
                <td class="expected-date">${expectedDate}</td>
                <td class="credit-limit">${limitText}</td>
                <td class="utilization ${debtor.utilizationPct > 80 ? 'high-util' : ''}">${utilizationText}</td>
            `;
        });
        
        // Добавляем итоговую строку
        const summaryRow = tbody.insertRow();
        summaryRow.className = 'summary-row';
        summaryRow.innerHTML = `
            <td><strong>ИТОГО (${sortedData.length})</strong></td>
            <td><strong>${formatters.currency(totalAR)}</strong></td>
            <td><strong>DSO: ${Math.round(calculatedDSO)} дн.</strong></td>
            <td colspan="4">Средняя просрочка: ${(sortedData.reduce((sum, d) => sum + (d.daysOverdue || 0), 0) / sortedData.length).toFixed(0)} дн.</td>
        `;
        
        container.innerHTML = '';
        container.appendChild(table);
        
        // Обновляем сводку по бакетам
        updateAgingBuckets(sortedData);
    }
    
    // Обновление блока aging buckets
    function updateAgingBuckets(debtors) {
        const buckets = {
            '0-30': 0,
            '31-60': 0,
            '61-90': 0,
            '90+': 0
        };
        
        debtors.forEach(debtor => {
            if (buckets.hasOwnProperty(debtor.bucket)) {
                buckets[debtor.bucket] += debtor.amount;
            }
        });
        
        // Обновляем DOM элементы бакетов
        Object.entries(buckets).forEach(([bucket, amount]) => {
            const element = document.querySelector('.bucket-' + bucket.replace(/[^a-z0-9]/gi, '-'));
            if (element) {
                element.textContent = `${bucket}: ${formatters.currency(amount)}`;
            }
        });
    }
    
    // Сортировка таблицы дебиторов
    function sortDebtorsTable(column) {
        if (!dashboardData || !dashboardData.debtors) return;
        
        const data = [...dashboardData.debtors];
        let sortOrder = 1; // По умолчанию по убыванию для сумм
        
        data.sort((a, b) => {
            let aVal = a[column];
            let bVal = b[column];
            
            if (column === 'amount' || column === 'creditLimit') {
                return sortOrder * (bVal - aVal); // Числа по убыванию
            } else if (column === 'daysOverdue') {
                return sortOrder * (bVal - aVal); // Просрочка по убыванию
            } else if (column === 'expectedDate') {
                aVal = new Date(aVal);
                bVal = new Date(bVal);
                return sortOrder * (aVal - bVal); // Даты по возрастанию
            } else {
                return sortOrder * aVal.localeCompare(bVal); // Строки по алфавиту
            }
        });
        
        // Пересоздаём таблицу с отсортированными данными
        dashboardData.debtors = data;
        createDebtorsTable(data);
    }

    // Расширенная сетка финансовых коэффициентов + спарклайны
    function createCoefficientsGrid(data) {
        const container = document.getElementById('coefficients-grid');
        if (!container) return;
        
        // Расчёт CCC если не передан
        const calculatedCCC = (data.dso || 0) + (data.dii || 0) - (data.dpo || 0);
        const cccValue = data.ccc !== undefined ? data.ccc : calculatedCCC;
        
        const coefficients = [
            // Ликвидность
            { 
                key: 'current', 
                name: 'Current Ratio', 
                value: data.current, 
                target: data.targets?.current || [1.5, 2.5],
                category: 'liquidity',
                description: 'Текущая ликвидность' 
            },
            { 
                key: 'quick', 
                name: 'Quick Ratio', 
                value: data.quick, 
                target: data.targets?.quick || [1.0, 2.0],
                category: 'liquidity',
                description: 'Быстрая ликвидность' 
            },
            
            // Долговая нагрузка
            { 
                key: 'debtEbitda', 
                name: 'Debt/EBITDA', 
                value: data.debtEbitda, 
                target: data.targets?.debtEbitda || [0.0, 3.0],
                category: 'leverage',
                description: 'Долговая нагрузка' 
            },
            { 
                key: 'interestCoverage', 
                name: 'Interest Coverage', 
                value: data.interestCoverage, 
                target: [3.0, 999],
                category: 'leverage',
                description: 'Покрытие процентов' 
            },
            { 
                key: 'autonomy', 
                name: 'Autonomy Ratio', 
                value: data.autonomy, 
                target: [0.5, 1.0],
                category: 'leverage',
                description: 'Автономность' 
            },
            
            // Оборачиваемость
            { 
                key: 'dso', 
                name: 'DSO', 
                value: data.dso, 
                target: [0, 45],
                unit: ' дн.',
                category: 'turnover',
                description: 'Дни продаж в дебиторке' 
            },
            { 
                key: 'dpo', 
                name: 'DPO', 
                value: data.dpo, 
                target: [30, 90],
                unit: ' дн.',
                category: 'turnover',
                description: 'Дни оплаты поставщикам' 
            },
            { 
                key: 'dii', 
                name: 'DII', 
                value: data.dii || 0, 
                target: [0, 30],
                unit: ' дн.',
                category: 'turnover',
                description: 'Дни запасов' 
            },
            { 
                key: 'ccc', 
                name: 'CCC', 
                value: cccValue, 
                target: data.targets?.ccc || [15, 45],
                unit: ' дн.',
                category: 'turnover',
                description: 'Цикл конвертации денег',
                formula: 'DSO + DII - DPO' 
            }
        ];
        
        container.innerHTML = '';
        
        // Создаём карточки коэффициентов
        coefficients.forEach(coeff => {
            if (coeff.value === undefined || coeff.value === null) return;
            
            const card = document.createElement('div');
            card.className = 'coefficient-card';
            card.setAttribute('data-category', coeff.category);
            card.setAttribute('title', coeff.description + (coeff.formula ? ' (' + coeff.formula + ')' : ''));
            
            // Определяем статус
            let status = 'normal';
            if (coeff.target) {
                if (coeff.value < coeff.target[0]) {
                    status = coeff.key === 'dpo' ? 'good' : 'warning'; // DPO: меньше - лучше
                } else if (coeff.value > coeff.target[1]) {
                    status = coeff.key === 'dpo' ? 'warning' : (coeff.key === 'interestCoverage' ? 'good' : 'warning');
                } else {
                    status = 'good';
                }
            }
            
            const statusColors = {
                good: 'ibcs-positive',
                warning: 'ibcs-negative',
                normal: 'ibcs-fact'
            };
            
            card.innerHTML = `
                <div class="coefficient-name">${coeff.name}</div>
                <div class="coefficient-value ${statusColors[status]}">
                    ${coeff.value.toFixed(1)}${coeff.unit || ''}
                </div>
                ${coeff.target ? `<div class="coefficient-target">
                    Норма: ${coeff.target[0]}-${coeff.target[1]}${coeff.unit || ''}
                </div>` : ''}
                <canvas id="sparkline-${coeff.key}" class="coefficient-sparkline" width="100" height="24"></canvas>
            `;
            
            container.appendChild(card);
            
            // Создание спарклайна
            setTimeout(() => {
                const sparklineData = data.sparklines && data.sparklines[coeff.key] 
                    ? data.sparklines[coeff.key]
                    : generateMockSparkline(coeff.value);
                    
                createOptimizedSparkline(`sparkline-${coeff.key}`, sparklineData, coeff.target);
            }, 10);
        });
        
        // Добавляем расчёт CCC для валидации
        if (data.dso && data.dii !== undefined && data.dpo) {
            const calculated = data.dso + (data.dii || 0) - data.dpo;
            if (Math.abs(calculated - cccValue) > 0.1) {
                console.warn(`CCC mismatch: calculated ${calculated.toFixed(1)}, provided ${cccValue.toFixed(1)}`);
            }
        }
    }
    
    // Оптимизированный спарклайн с поддержкой нормативов и HiDPI
    function createOptimizedSparkline(canvasId, data, target, width = 100, height = 24) {
        const canvas = document.getElementById(canvasId);
        if (!canvas || data.length < 2) return;
        
        // Apply HiDPI scaling first
        ensureHiDPI(canvas);
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, width, height);
        
        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min || 1;
        const padding = 2;
        
        // Зона нормы (если есть target)
        if (target && target.length === 2) {
            const targetMin = Math.max(min, target[0]);
            const targetMax = Math.min(max, target[1]);
            
            if (targetMin <= targetMax) {
                const yMin = height - padding - ((targetMin - min) / range) * (height - 2 * padding);
                const yMax = height - padding - ((targetMax - min) / range) * (height - 2 * padding);
                
                ctx.fillStyle = '#34c759';
                ctx.globalAlpha = 0.2;
                ctx.fillRect(0, yMax, width, yMin - yMax);
                ctx.globalAlpha = 1.0;
            }
        }
        
        // Линия тренда
        ctx.strokeStyle = IBCS_COLORS.fact;
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        
        data.forEach((value, index) => {
            const x = (index / (data.length - 1)) * width;
            const y = height - padding - ((value - min) / range) * (height - 2 * padding);
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.stroke();
        
        // Точка последнего значения
        const lastValue = data[data.length - 1];
        const lastX = width;
        const lastY = height - padding - ((lastValue - min) / range) * (height - 2 * padding);
        
        ctx.fillStyle = IBCS_COLORS.fact;
        ctx.beginPath();
        ctx.arc(lastX - 2, lastY, 2, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // Генерация mock данных для спарклайна
    function generateMockSparkline(currentValue, length = 5) {
        const data = [];
        const variation = currentValue * 0.1; // 10% вариация
        
        for (let i = 0; i < length; i++) {
            const trend = (i - length/2) * 0.02 * currentValue; // Небольшой тренд
            const noise = (Math.random() - 0.5) * variation;
            data.push(Math.max(0, currentValue + trend + noise));
        }
        
        // Последнее значение = текущему
        data[length - 1] = currentValue;
        return data;
    }

    // Создание таблицы счетов
    function createAccountsTable(data) {
        const container = document.getElementById('accounts-table');
        if (!container) return;
        
        const table = document.createElement('table');
        table.className = 'accounts-table';
        
        const header = table.createTHead();
        const headerRow = header.insertRow();
        ['Банк', 'Доступно', 'Заморожено', 'Концентрация'].forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
        });
        
        const tbody = table.createTBody();
        data.forEach((account, index) => {
            const row = tbody.insertRow();
            row.innerHTML = `
                <td>${account.bank}</td>
                <td>${formatters.currency(account.available)}</td>
                <td>${formatters.currency(account.blocked)}</td>
                <td>${formatters.percent(account.concentration)}</td>
            `;
        });
        
        container.innerHTML = '';
        container.appendChild(table);
    }

    // Состояние алертов
    let alertsState = {
        minimized: false,
        currentSeverityFilter: 'all',
        dismissed: [],
        snoozed: {}
    };

    // Загрузка состояния алертов из localStorage  
    function loadAlertsState() {
        try {
            const stored = localStorage.getItem('dash.alerts');
            if (stored) {
                const parsed = JSON.parse(stored);
                alertsState = {...alertsState, ...parsed};
            }
        } catch (error) {
            console.warn('Failed to load alerts state:', error);
        }
    }

    // Сохранение состояния алертов
    function saveAlertsState() {
        try {
            localStorage.setItem('dash.alerts', JSON.stringify(alertsState));
        } catch (error) {
            console.warn('Failed to save alerts state:', error);
        }
    }

    // Фильтрация алертов
    function filterAlerts(alerts) {
        if (!alerts) return [];
        
        const now = Date.now();
        
        return alerts.filter(alert => {
            // Исключаем dismissed алерты
            if (alertsState.dismissed.includes(alert.id || alert.type)) {
                return false;
            }
            
            // Исключаем snoozed алерты
            const snoozeInfo = alertsState.snoozed[alert.id || alert.type];
            if (snoozeInfo && now < snoozeInfo.until) {
                return false;
            }
            
            // Фильтр по severity
            if (alertsState.currentSeverityFilter !== 'all') {
                return alert.severity === alertsState.currentSeverityFilter;
            }
            
            return true;
        });
    }

    // Получение иконки для типа алерта
    function getAlertIcon(alertType) {
        const icons = {
            cash_shortage: '💰',
            overdue: '⏰', 
            concentration: '🏦',
            liquidity_risk: '💧',
            debt_burden: '📊',
            margin_decline: '📉',
            default: '⚠️'
        };
        return icons[alertType] || icons.default;
    }

    // Получение цели для перехода по алерту
    function getAlertTarget(alertType) {
        const targets = {
            cash_shortage: 'cash-accounts-container',
            overdue: 'debtors-container', 
            concentration: 'cash-accounts-container',
            liquidity_risk: 'coefficients-container',
            debt_burden: 'coefficients-container',
            margin_decline: 'margins-trend-container',
            dso_deterioration: 'debtors-container',
            ccc_deterioration: 'coefficients-container'
        };
        return targets[alertType] || null;
    }

    // Переход к источнику алерта с подсветкой
    function jumpToAlertSource(alertType) {
        const targetId = getAlertTarget(alertType);
        if (!targetId) return;

        const targetElement = document.getElementById(targetId);
        if (targetElement) {
            // Скролл к элементу
            targetElement.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
            
            // Подсветка на 1.5 секунды
            targetElement.classList.add('highlighted');
            setTimeout(() => {
                targetElement.classList.remove('highlighted');
            }, 1500);
            
            // Закрываем панель алертов
            toggleAlertsPanel(false);
        }
    }

    // Dismiss алерта навсегда
    function dismissAlert(alertId) {
        if (!alertsState.dismissed.includes(alertId)) {
            alertsState.dismissed.push(alertId);
            saveAlertsState();
            updateAlertsDisplay();
        }
    }

    // Snooze алерта
    function snoozeAlert(alertId, duration) {
        const now = Date.now();
        const durations = {
            '24h': 24 * 60 * 60 * 1000,
            '7d': 7 * 24 * 60 * 60 * 1000
        };
        
        alertsState.snoozed[alertId] = {
            until: now + durations[duration],
            snoozeTime: now
        };
        
        saveAlertsState();
        updateAlertsDisplay();
    }

    // Переключение панели алертов
    function toggleAlertsPanel(forceOpen = null) {
        const panel = document.getElementById('alerts-panel');
        const bell = document.getElementById('alerts-bell');
        
        if (forceOpen !== null) {
            alertsState.minimized = !forceOpen;
        } else {
            alertsState.minimized = !alertsState.minimized;
        }
        
        panel.classList.toggle('open', !alertsState.minimized);
        saveAlertsState();
    }

    // Создание HTML для алерта
    function createAlertHTML(alert, index) {
        const alertId = alert.id || `${alert.type}-${index}`;
        const icon = getAlertIcon(alert.type);
        const timeAgo = alert.timestamp ? getTimeAgo(alert.timestamp) : 'Сейчас';
        
        return `
            <div class="alert-item severity-${alert.severity}" data-alert-id="${alertId}">
                <div class="alert-header">
                    <div class="alert-title">${icon} ${alert.type.toUpperCase()}</div>
                    <div class="alert-actions">
                        <button class="alert-action-btn alert-snooze" data-alert-id="${alertId}" data-duration="24h" title="Отложить на 24 часа">
                            💤
                        </button>
                        <button class="alert-action-btn alert-jump" data-alert-type="${alert.type}" title="Перейти к источнику">
                            🔍
                        </button>
                        <button class="alert-action-btn alert-dismiss" data-alert-id="${alertId}" title="Скрыть навсегда">
                            ✕
                        </button>
                    </div>
                </div>
                <div class="alert-message">${alert.message}</div>
                <div class="alert-meta">
                    <span class="alert-time">${timeAgo}</span>
                    <span class="alert-source-link" data-alert-type="${alert.type}">
                        Перейти к деталям →
                    </span>
                </div>
            </div>
        `;
    }

    // Получение времени "назад"
    function getTimeAgo(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        
        const minutes = Math.floor(diff / (1000 * 60));
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        
        if (days > 0) return `${days} дн. назад`;
        if (hours > 0) return `${hours} ч. назад`;
        if (minutes > 0) return `${minutes} мин. назад`;
        return 'Только что';
    }

    // Обновление отображения алертов
    function updateAlertsDisplay() {
        if (!dashboardData?.alerts) return;
        
        const filteredAlerts = filterAlerts(dashboardData.alerts);
        const alertsBody = document.getElementById('alerts-body');
        const alertsBell = document.getElementById('alerts-bell');
        const alertsCounter = document.getElementById('alerts-counter');
        
        // Обновляем счетчик
        const alertCount = filteredAlerts.length;
        if (alertCount > 0) {
            alertsCounter.textContent = alertCount;
            alertsCounter.style.display = 'flex';
            
            // Проверяем наличие критических алертов
            const hasCritical = filteredAlerts.some(alert => alert.severity === 'critical');
            alertsBell.classList.toggle('has-critical', hasCritical);
        } else {
            alertsCounter.style.display = 'none';
            alertsBell.classList.remove('has-critical');
        }
        
        // Обновляем содержимое панели
        if (alertCount === 0) {
            alertsBody.innerHTML = `
                <div class="alerts-empty">
                    <svg class="alerts-empty-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <div>Нет активных алертов</div>
                </div>
            `;
        } else {
            alertsBody.innerHTML = filteredAlerts
                .map((alert, index) => createAlertHTML(alert, index))
                .join('');

            alertsBody.querySelectorAll('.alert-snooze').forEach(btn => {
                btn.addEventListener('click', () => {
                    snoozeAlert(btn.dataset.alertId, btn.dataset.duration);
                });
            });

            alertsBody.querySelectorAll('.alert-jump').forEach(btn => {
                btn.addEventListener('click', () => {
                    jumpToAlertSource(btn.dataset.alertType);
                });
            });

            alertsBody.querySelectorAll('.alert-dismiss').forEach(btn => {
                btn.addEventListener('click', () => {
                    dismissAlert(btn.dataset.alertId);
                });
            });

            alertsBody.querySelectorAll('.alert-source-link').forEach(link => {
                link.addEventListener('click', () => {
                    jumpToAlertSource(link.dataset.alertType);
                });
            });
        }
    }

    // Инициализация системы алертов
    function initializeAlerts() {
        loadAlertsState();
        
        // Обработчик клика по колокольчику
        document.getElementById('alerts-bell').addEventListener('click', function() {
            toggleAlertsPanel();
        });
        
        // Обработчики фильтров severity
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('severity-filter-btn')) {
                // Обновляем активный фильтр
                document.querySelectorAll('.severity-filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                e.target.classList.add('active');
                
                // Сохраняем и применяем фильтр
                alertsState.currentSeverityFilter = e.target.dataset.severity;
                saveAlertsState();
                updateAlertsDisplay();
            }
        });
        
        // Закрытие панели при клике вне её
        document.addEventListener('click', function(e) {
            const panel = document.getElementById('alerts-panel');
            const bell = document.getElementById('alerts-bell');
            
            if (!panel.contains(e.target) && !bell.contains(e.target)) {
                if (!alertsState.minimized) {
                    toggleAlertsPanel(false);
                }
            }
        });
        
        // Восстанавливаем состояние панели
        const panel = document.getElementById('alerts-panel');
        panel.classList.toggle('open', !alertsState.minimized);
        
        // Восстанавливаем активный фильтр
        document.querySelectorAll('.severity-filter-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.severity === alertsState.currentSeverityFilter);
        });
    }

    // Генерация алертов на основе данных и правил из alerts-config.json
    function generateAlerts(data) {
        if (!window.alertsConfig) {
            // Загружаем конфигурацию алертов если еще не загружена
            loadAlertsConfig().then(() => generateAlerts(data));
            return;
        }
        
        const alerts = [];
        const rules = window.alertsConfig.alertRules;
        const now = Date.now();
        
        Object.entries(rules).forEach(([ruleId, rule]) => {
            try {
                let value = null;
                
                // Получаем значение метрики по пути
                switch (rule.metric) {
                    case 'cashRunwayMonths':
                        value = data.kpi?.cashRunwayMonths;
                        break;
                    case 'coefficients.dso':
                        value = data.coefficients?.dso;
                        break;
                    case 'coefficients.ccc':
                        value = data.coefficients?.ccc;
                        break;
                    case 'coefficients.current':
                        value = data.coefficients?.current;
                        break;
                    case 'coefficients.debtEbitda':
                        value = data.coefficients?.debtEbitda;
                        break;
                    case 'maxBankConcentration':
                        value = Math.max(...(data.cashAccounts?.map(acc => acc.concentration) || [0]));
                        break;
                    case 'arAging.buckets.90+':
                        // Используем единый расчёт просрочки 90+ (Task 4 - Sprint 5)
                        const arData = getUnifiedARAgingData(data);
                        value = arData.buckets['90+'] || 0;
                        break;
                }
                
                if (value !== null && value !== undefined) {
                    // Проверяем условие
                    let triggered = false;
                    const thresholds = rule.thresholds;
                    let severity = 'low';
                    
                    if (rule.operator === 'greater_than') {
                        if (value > thresholds.critical) {
                            triggered = true;
                            severity = 'critical';
                        } else if (value > thresholds.high) {
                            triggered = true;
                            severity = 'high';
                        } else if (value > thresholds.medium) {
                            triggered = true;
                            severity = 'medium';
                        }
                    } else if (rule.operator === 'less_than') {
                        if (value < thresholds.critical) {
                            triggered = true;
                            severity = 'critical';
                        } else if (value < thresholds.high) {
                            triggered = true;
                            severity = 'high';
                        } else if (value < thresholds.medium) {
                            triggered = true;
                            severity = 'medium';
                        }
                    }
                    
                    if (triggered) {
                        // Форматируем сообщение
                        const message = rule.message.replace('{value}', 
                            typeof value === 'number' ? value.toFixed(1) : value);
                        
                        alerts.push({
                            id: ruleId,
                            type: ruleId,
                            severity: severity,
                            message: message,
                            value: value,
                            threshold: thresholds[severity],
                            timestamp: now,
                            recommendations: rule.recommendations || []
                        });
                    }
                }
            } catch (error) {
                console.warn(`Error processing alert rule ${ruleId}:`, error);
            }
        });
        
        return alerts;
    }

    // Загрузка конфигурации алертов
    async function loadAlertsConfig() {
        try {
            const response = await fetch('./alerts-config.json');
            window.alertsConfig = await response.json();
        } catch (error) {
            console.warn('Failed to load alerts config:', error);
            // Fallback конфигурация
            window.alertsConfig = {
                alertRules: {
                    cash_shortage: {
                        message: "Cash Runway менее {value} мес",
                        thresholds: { critical: 1, high: 3, medium: 6 },
                        operator: "less_than"
                    }
                }
            };
        }
    }

    // Расширенная функция отображения алертов с интеграцией правил
    function displayAlerts(alerts) {
        if (!alerts) {
            // Генерируем алерты на основе текущих данных
            if (dashboardData) {
                alerts = generateAlerts(dashboardData);
                dashboardData.alerts = alerts;
            }
        }
        
        updateAlertsDisplay();
    }

    // Cash forecast functionality (Task 1 - Sprint 5)
    let currentForecastScenario = 'base';
    
    function generateCashForecast(scenario = 'base') {
        const params = window._cashForecastParams || {};
        const baseData = dashboardData;
        
        // Generate 4-8 weeks forecast data
        const weeks = [];
        const collections = [];
        const payments = [];
        const balances = [];
        
        let currentBalance = baseData?.kpi?.cashEnd || 45.6;
        const startDate = new Date();
        
        // Scenario multipliers
        const scenarioMultipliers = {
            base: { collections: 1.0, payments: 1.0 },
            optimistic: { collections: 1.15, payments: 0.9 },
            pessimistic: { collections: 0.85, payments: 1.1 }
        };
        
        const multiplier = scenarioMultipliers[scenario] || scenarioMultipliers.base;
        
        for (let week = 1; week <= 8; week++) {
            const weekDate = new Date(startDate.getTime() + week * 7 * 24 * 60 * 60 * 1000);
            weeks.push(`W${week} (${weekDate.getDate()}.${weekDate.getMonth() + 1})`);
            
            // Generate weekly collections and payments with seasonal adjustment
            const seasonalFactor = params.seasonalAdjustment ? 
                1 + 0.1 * Math.sin(week * Math.PI / 4) : 1.0;
            
            const weeklyCollections = (12.5 + Math.random() * 5) * multiplier.collections * seasonalFactor;
            const weeklyPayments = (8.2 + Math.random() * 3) * multiplier.payments * seasonalFactor;
            
            collections.push(weeklyCollections);
            payments.push(weeklyPayments);
            
            currentBalance = currentBalance + weeklyCollections - weeklyPayments;
            balances.push(currentBalance);
        }
        
        return {
            weeks,
            collections,
            payments,
            balances,
            scenario
        };
    }
    
    function updateCashForecast() {
        const forecastData = generateCashForecast(currentForecastScenario);
        
        // Update chart if it exists
        if (charts['weekly-forecast-chart']) {
            updateCashForecastChart(forecastData);
        } else {
            createCashForecastChart(forecastData);
        }
        
        // Update detail tables
        updateForecastDetails(forecastData);
        
        // Check for cash shortage alerts
        checkCashShortageAlert(forecastData.balances);
    }
    
    function createCashForecastChart(data) {
        const canvas = document.getElementById('weekly-forecast-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const chart = createLineChart('weekly-forecast-chart', {
            dates: data.weeks,
            fact: data.balances,
            plan: data.collections,
            prevYear: data.payments
        }, formatters.millions);
        
        charts['weekly-forecast-chart'] = chart;
        
        // Override chart colors for cash forecast
        if (chart && chart.data) {
            chart.data.datasets = [
                {
                    label: 'Cash Balance',
                    data: data.balances,
                    borderColor: '#27ae60',
                    backgroundColor: 'rgba(39, 174, 96, 0.1)',
                    borderWidth: 3,
                    fill: true
                },
                {
                    label: 'Инкассации',
                    data: data.collections,
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    borderWidth: 2
                },
                {
                    label: 'Платежи',
                    data: data.payments,
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    borderWidth: 2
                }
            ];
            chart.update();
        }
    }
    
    function updateCashForecastChart(data) {
        const chart = charts['weekly-forecast-chart'];
        if (!chart) return createCashForecastChart(data);
        
        chart.data.labels = data.weeks;
        chart.data.datasets[0].data = data.balances;
        chart.data.datasets[1].data = data.collections;
        chart.data.datasets[2].data = data.payments;
        chart.update();
    }
    
    function updateForecastDetails(data) {
        const collectionsEl = document.getElementById('forecast-collections');
        const paymentsEl = document.getElementById('forecast-payments');
        const balanceEl = document.getElementById('forecast-balance');
        
        if (collectionsEl) {
            const totalCollections = data.collections.reduce((sum, val) => sum + val, 0);
            collectionsEl.innerHTML = `<strong>${formatters.millions(totalCollections)} млн ₽</strong><br>
                <small>Всего за 8 недель</small>`;
        }
        
        if (paymentsEl) {
            const totalPayments = data.payments.reduce((sum, val) => sum + val, 0);
            paymentsEl.innerHTML = `<strong>${formatters.millions(totalPayments)} млн ₽</strong><br>
                <small>Всего за 8 недель</small>`;
        }
        
        if (balanceEl) {
            const finalBalance = data.balances[data.balances.length - 1];
            const changeColor = finalBalance > data.balances[0] ? '#27ae60' : '#e74c3c';
            balanceEl.innerHTML = `<strong style="color: ${changeColor}">${formatters.millions(finalBalance)} млн ₽</strong><br>
                <small>Прогноз через 8 недель</small>`;
        }
    }
    
    function checkCashShortageAlert(balances) {
        const minBalance = Math.min(...balances);
        if (minBalance < 0) {
            // Add cash shortage alert
            const alert = {
                type: 'cash_shortage',
                severity: 'critical',
                message: `Прогнозируется дефицит ДС: ${formatters.millions(minBalance)} млн ₽`,
                value: minBalance,
                threshold: 0
            };
            
            // Add to alerts if not already present
            if (dashboardData && dashboardData.alerts) {
                const existingAlert = dashboardData.alerts.find(a => a.type === 'cash_shortage');
                if (!existingAlert) {
                    dashboardData.alerts.push(alert);
                    displayAlerts(dashboardData.alerts);
                }
            }
        }
    }
    
    function initializeCashForecastControls() {
        // Initialize default forecast parameters
        window._cashForecastParams = {
            scenarioWeights: { base: 1.0, optimistic: 1.15, pessimistic: 0.85 },
            seasonalAdjustment: false,
            includeFixedCosts: true
        };
        
        // Add event listeners for scenario buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('scenario-btn')) {
                // Update active button
                document.querySelectorAll('.scenario-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                
                // Update scenario and forecast
                currentForecastScenario = e.target.dataset.scenario;
                
                // Performance requirement: switching scenarios ≤25ms
                const startTime = performance.now();
                updateCashForecast();
                const endTime = performance.now();
                
                if (endTime - startTime > 25) {
                    console.warn(`Scenario switch took ${endTime - startTime}ms, exceeds 25ms requirement`);
                }
            }
        });
    }

    // EBITDA drivers functionality (Task 2 - Sprint 5)
    let ebitdaDisplayMode = 'values'; // 'values' or 'margin'
    
    function generateEbitdaDriversData() {
        const baseData = dashboardData;
        const planEbitda = baseData?.kpi?.ebitda || 85.4;
        const factEbitda = 78.2; // This would come from actual data
        const totalVariance = factEbitda - planEbitda;
        
        // EBITDA drivers breakdown (Plan → Drivers → Fact)
        const drivers = [
            { driver: 'Plan', value: planEbitda, cumulative: planEbitda, type: 'plan' },
            { driver: 'Price', value: 5.2, cumulative: planEbitda + 5.2, type: 'positive' },
            { driver: 'Volume', value: -2.8, cumulative: planEbitda + 5.2 - 2.8, type: 'negative' },
            { driver: 'Mix', value: 1.5, cumulative: planEbitda + 5.2 - 2.8 + 1.5, type: 'positive' },
            { driver: 'FX', value: -3.1, cumulative: planEbitda + 5.2 - 2.8 + 1.5 - 3.1, type: 'negative' },
            { driver: 'COGS', value: -4.2, cumulative: planEbitda + 5.2 - 2.8 + 1.5 - 3.1 - 4.2, type: 'negative' },
            { driver: 'OPEX', value: -2.0, cumulative: planEbitda + 5.2 - 2.8 + 1.5 - 3.1 - 4.2 - 2.0, type: 'negative' },
            { driver: 'Fact', value: factEbitda, cumulative: factEbitda, type: 'fact' }
        ];
        
        // Calculate margin impact for each driver
        const revenue = baseData?.kpi?.revenue?.current || 520;
        const driversWithMargin = drivers.map(d => ({
            ...d,
            marginImpact: d.type === 'plan' || d.type === 'fact' ? 
                (d.value / revenue * 100) : 
                (d.value / revenue * 100)
        }));
        
        // Sort drivers by absolute impact (excluding Plan and Fact)
        const sortedDrivers = [
            driversWithMargin[0], // Plan
            ...driversWithMargin.slice(1, -1).sort((a, b) => Math.abs(b.value) - Math.abs(a.value)),
            driversWithMargin[driversWithMargin.length - 1] // Fact
        ];
        
        return {
            drivers: sortedDrivers,
            totalVariance,
            planEbitda,
            factEbitda,
            revenue
        };
    }
    
    function createEbitdaDriversChart() {
        const data = generateEbitdaDriversData();
        const canvas = document.getElementById('ebitda-bridge-chart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        // Create waterfall chart with EBITDA drivers
        const chart = createDriversWaterfallChart(canvas.id, data);
        charts['ebitda-bridge-chart'] = chart;
        
        // Add hover tooltips with driver details
        if (chart) {
            chart._driversData = data;
        }
    }
    
    function createDriversWaterfallChart(canvasId, data) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return null;
        
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        
        // Ensure HiDPI rendering
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        
        const padding = { top: 40, right: 40, bottom: 60, left: 60 };
        const chartWidth = rect.width - padding.left - padding.right;
        const chartHeight = rect.height - padding.top - padding.bottom;
        
        // Determine Y-axis range
        const values = data.drivers.map(d => ebitdaDisplayMode === 'values' ? d.value : d.marginImpact);
        const maxValue = Math.max(...values);
        const minValue = Math.min(...values);
        const range = maxValue - minValue;
        const yScale = chartHeight / (range * 1.2);
        
        // Driver colors
        const driverColors = {
            'Plan': '#7f8c8d',
            'Price': '#3498db',
            'Volume': '#27ae60',
            'Mix': '#f39c12',
            'FX': '#9b59b6',
            'COGS': '#e74c3c',
            'OPEX': '#34495e',
            'Fact': '#2c3e50'
        };
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw waterfall bars
        const barWidth = chartWidth / (data.drivers.length + 1);
        let cumulativeY = chartHeight + padding.top;
        
        data.drivers.forEach((driver, index) => {
            const x = padding.left + index * barWidth;
            const value = ebitdaDisplayMode === 'values' ? driver.value : driver.marginImpact;
            const barHeight = Math.abs(value) * yScale;
            const y = driver.type === 'plan' || driver.type === 'fact' ? 
                chartHeight + padding.top - barHeight :
                cumulativeY - (value > 0 ? barHeight : 0);
            
            // Bar color
            const color = driverColors[driver.driver] || '#95a5a6';
            ctx.fillStyle = driver.value > 0 ? color : color + 'AA';
            
            // Draw bar
            ctx.fillRect(x + barWidth * 0.1, y - (value < 0 ? barHeight : 0), barWidth * 0.8, barHeight);
            
            // Draw connecting lines (bridge effect)
            if (index > 0 && driver.type !== 'plan' && driver.type !== 'fact') {
                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(x, cumulativeY);
                ctx.lineTo(x + barWidth * 0.1, y + (value < 0 ? 0 : barHeight));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Labels
            ctx.fillStyle = '#2c3e50';
            ctx.font = '11px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            
            // Driver name
            ctx.fillText(driver.driver, x + barWidth * 0.5, chartHeight + padding.top + 20);
            
            // Value label
            const displayValue = ebitdaDisplayMode === 'values' ? 
                `${value > 0 ? '+' : ''}${formatters.millions(value)}` :
                `${value > 0 ? '+' : ''}${value.toFixed(1)}%`;
            
            ctx.fillText(displayValue, x + barWidth * 0.5, y - (value < 0 ? barHeight + 5 : -15));
            
            if (driver.type !== 'plan' && driver.type !== 'fact') {
                cumulativeY = y + (value < 0 ? 0 : barHeight);
            }
        });
        
        // Y-axis
        ctx.strokeStyle = '#bdc3c7';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top);
        ctx.lineTo(padding.left, chartHeight + padding.top);
        ctx.stroke();
        
        // Chart title
        ctx.fillStyle = '#2c3e50';
        ctx.font = '12px -apple-system, sans-serif';
        ctx.textAlign = 'left';
        const title = `EBITDA: План → Факт (${data.totalVariance > 0 ? '+' : ''}${formatters.millions(data.totalVariance)})`;
        ctx.fillText(title, padding.left, padding.top - 10);
        
        // Store chart data for interactions
        const chart = {
            canvas,
            data: data,
            update: () => createDriversWaterfallChart(canvasId, data),
            _driversData: data
        };
        
        return chart;
    }
    
    function updateEbitdaDisplayMode(mode) {
        ebitdaDisplayMode = mode;
        
        // Update button states
        document.querySelectorAll('#ebitda-values-btn, #ebitda-margin-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        const activeBtn = mode === 'values' ? 
            document.getElementById('ebitda-values-btn') : 
            document.getElementById('ebitda-margin-btn');
        
        if (activeBtn) activeBtn.classList.add('active');
        
        // Recreate chart with new mode
        if (charts['ebitda-bridge-chart']) {
            createEbitdaDriversChart();
        }
    }
    
    function initializeEbitdaDrivers() {
        // Add event listeners for display mode toggle
        document.addEventListener('click', function(e) {
            if (e.target.id === 'ebitda-values-btn') {
                updateEbitdaDisplayMode('values');
            } else if (e.target.id === 'ebitda-margin-btn') {
                updateEbitdaDisplayMode('margin');
            }
        });
    }

    // Role-based presets functionality (Task 3 - Sprint 5)
    const ROLE_PRESETS = {
        CEO: {
            startPage: 'overview',
            defaultFilters: {
                company: 'progress',
                organization: 'hq',
                counterparty: 'all',
                manager: 'all',
                dateFrom: null,
                dateTo: null
            },
            alertsExpanded: false,
            shareMode: 'full', // минимум контролов для CEO
            density: 'normal'
        },
        CFO: {
            startPage: 'cash',
            defaultFilters: {
                company: 'progress',
                organization: 'all',
                counterparty: 'all',
                manager: 'all',
                dateFrom: null,
                dateTo: null
            },
            alertsExpanded: true, // раскрытая панель алертов для CFO
            shareMode: 'full',
            density: 'normal'
        },
        Sales: {
            startPage: 'profit', // Продажи = Прибыльность
            defaultFilters: {
                company: 'progress',
                organization: 'all',
                counterparty: 'top10',
                manager: 'all',
                dateFrom: null,
                dateTo: null
            },
            alertsExpanded: false,
            shareMode: 'percent', // включён абсолют/100% для Sales
            density: 'normal'
        }
    };
    
    function applyRolePreset(role) {
        const preset = ROLE_PRESETS[role];
        if (!preset) {
            console.warn(`Unknown role: ${role}`);
            return;
        }
        
        // Apply filters
        currentFilters = {...currentFilters, ...preset.defaultFilters};
        applyFiltersToUI();
        
        // Set start page
        if (preset.startPage !== currentPage) {
            setPage(preset.startPage);
        }
        
        // Set alerts panel state
        const alertsPanel = document.getElementById('alerts-panel');
        const alertsBell = document.getElementById('alerts-bell');
        
        if (preset.alertsExpanded && alertsPanel && alertsBell) {
            alertsPanel.classList.add('open');
            alertsBell.classList.add('active');
        } else if (alertsPanel && alertsBell) {
            alertsPanel.classList.remove('open');
            alertsBell.classList.remove('active');
        }
        
        // Set share mode
        if (preset.shareMode === 'percent') {
            // Enable percentage mode for Sales role
            const shareToggle = document.querySelector('.share-mode-toggle');
            if (shareToggle) {
                const percentBtn = shareToggle.querySelector('[data-mode="percent"]');
                if (percentBtn) {
                    shareToggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    percentBtn.classList.add('active');
                    // Apply the mode
                    currentShareMode = 'percent';
                    updateChartsShareMode();
                }
            }
        }
        
        // Apply density if different
        if (preset.density !== 'normal') {
            const dashboardEl = document.getElementById('dashboard');
            if (dashboardEl) {
                dashboardEl.className = dashboardEl.className.replace(/density-\w+/, '') + ` density-${preset.density}`;
            }
        }
        
        console.log(`Applied role preset: ${role}`);
    }
    
    function initializeRolePresets() {
        // Check for stored role and apply it
        const storedRole = localStorage.getItem('dash.role');
        if (storedRole && ROLE_PRESETS[storedRole]) {
            // Delay to ensure DOM is ready
            setTimeout(() => {
                applyRolePreset(storedRole);
            }, 100);
        }
    }

    // Data quality and unified calculations (Task 4 - Sprint 5)
    function calcARAgingBuckets(debtors) {
        if (!debtors || !Array.isArray(debtors)) {
            return {
                buckets: { '0-30': 0, '31-60': 0, '61-90': 0, '90+': 0 },
                totalAR: 0
            };
        }
        
        const buckets = { '0-30': 0, '31-60': 0, '61-90': 0, '90+': 0 };
        let totalAR = 0;
        
        debtors.forEach(debtor => {
            const amount = debtor.amount || 0;
            const days = debtor.daysOverdue || 0;
            totalAR += amount;
            
            if (days <= 30) {
                buckets['0-30'] += amount;
            } else if (days <= 60) {
                buckets['31-60'] += amount;
            } else if (days <= 90) {
                buckets['61-90'] += amount;
            } else {
                buckets['90+'] += amount;
            }
        });
        
        return { buckets, totalAR };
    }
    
    function validateDataConsistency(data) {
        const errors = [];
        const warnings = [];
        
        // Validate AR aging consistency
        if (data.debtors && data.arAging) {
            const calculated = calcARAgingBuckets(data.debtors);
            const provided = data.arAging;
            
            // Check if bucket sums match total AR
            const calculatedTotal = Object.values(calculated.buckets).reduce((sum, val) => sum + val, 0);
            if (Math.abs(calculatedTotal - calculated.totalAR) > 0.01) {
                errors.push(`AR buckets sum (${calculatedTotal}) doesn't match total AR (${calculated.totalAR})`);
            }
            
            if (provided.totalAR && Math.abs(calculated.totalAR - provided.totalAR) > 0.01) {
                errors.push(`Calculated total AR (${calculated.totalAR}) doesn't match provided total AR (${provided.totalAR})`);
            }
            
            // Check individual buckets
            Object.keys(calculated.buckets).forEach(bucket => {
                const calc = calculated.buckets[bucket];
                const prov = provided.buckets?.[bucket];
                if (prov !== undefined && Math.abs(calc - prov) > 0.01) {
                    warnings.push(`Bucket ${bucket}: calculated (${calc}) vs provided (${prov})`);
                }
            });
        }
        
        // Validate time series data consistency
        if (data.timeSeries) {
            Object.keys(data.timeSeries).forEach(seriesKey => {
                const series = data.timeSeries[seriesKey];
                if (series.dates && series.dates.length > 0) {
                    // Check if all data arrays have same length as dates
                    Object.keys(series).forEach(key => {
                        if (key !== 'dates' && Array.isArray(series[key])) {
                            if (series[key].length !== series.dates.length) {
                                errors.push(`${seriesKey}.${key} length (${series[key].length}) doesn't match dates length (${series.dates.length})`);
                            }
                        }
                    });
                }
            });
        }
        
        // Validate cash accounts concentration
        if (data.cashAccounts) {
            data.cashAccounts.forEach((account, index) => {
                if (account.concentration < 0 || account.concentration > 100) {
                    warnings.push(`Account ${index} (${account.bank}) has invalid concentration: ${account.concentration}%`);
                }
            });
            
            const totalConcentration = data.cashAccounts.reduce((sum, acc) => sum + acc.concentration, 0);
            if (Math.abs(totalConcentration - 100) > 1) {
                warnings.push(`Total cash concentration is ${totalConcentration}%, expected ~100%`);
            }
        }
        
        // Validate coefficient relationships
        if (data.coefficients) {
            const coeffs = data.coefficients;
            
            // DSO + DII should be greater than DPO for positive CCC
            if (coeffs.dso && coeffs.dii && coeffs.dpo && coeffs.ccc) {
                const expectedCCC = coeffs.dso + coeffs.dii - coeffs.dpo;
                if (Math.abs(expectedCCC - coeffs.ccc) > 1) {
                    warnings.push(`CCC calculation: expected ${expectedCCC}, got ${coeffs.ccc}`);
                }
            }
            
            // Quick ratio should be less than or equal to current ratio
            if (coeffs.current && coeffs.quick && coeffs.quick > coeffs.current) {
                warnings.push(`Quick ratio (${coeffs.quick}) cannot be greater than current ratio (${coeffs.current})`);
            }
        }
        
        return { 
            isValid: errors.length === 0, 
            errors, 
            warnings,
            summary: `${errors.length} error(s), ${warnings.length} warning(s)`
        };
    }
    
    function getUnifiedARAgingData(data) {
        // Always use calculated data to ensure consistency
        const calculated = calcARAgingBuckets(data.debtors);
        
        // Override provided data with calculated values
        if (data.arAging) {
            data.arAging.buckets = calculated.buckets;
            data.arAging.totalAR = calculated.totalAR;
        } else {
            data.arAging = calculated;
        }
        
        return data.arAging;
    }
    
    // Update alert triggers to use unified calculation
    function checkOverdueARAlert(data) {
        const arData = getUnifiedARAgingData(data);
        const overdueAmount = arData.buckets['90+'];
        
        if (overdueAmount > 0) {
            const alert = {
                type: 'overdue_ar',
                severity: overdueAmount > 5000000 ? 'critical' : 'high',
                message: `Критическая просрочка: ${formatters.millions(overdueAmount)} млн ₽`,
                value: overdueAmount,
                threshold: 0
            };
            
            // Add or update alert in dashboard data
            if (!data.alerts) data.alerts = [];
            const existingIndex = data.alerts.findIndex(a => a.type === 'overdue_ar');
            if (existingIndex >= 0) {
                data.alerts[existingIndex] = alert;
            } else {
                data.alerts.push(alert);
            }
        }
        
        return overdueAmount;
    }

    // Основная функция рендеринга
    function renderDashboard(data) {
        dashboardData = data;
        
        // Data quality validation (Task 4 - Sprint 5)
        const validation = validateDataConsistency(data);
        if (!validation.isValid) {
            console.error('Data validation failed:', validation.errors);
        }
        if (validation.warnings.length > 0) {
            console.warn('Data validation warnings:', validation.warnings);
        }
        
        // Apply unified AR aging calculation
        getUnifiedARAgingData(data);
        
        // Check for overdue AR alerts using unified calculation
        checkOverdueARAlert(data);
        
        // Обновление KPI
        updateKPICards(data);
        
        // Создание графиков
        if (data.timeSeries.revenue) {
            charts['revenue-trend-chart'] = createLineChart(
                'revenue-trend-chart', 
                data.timeSeries.revenue,
                formatters.millions
            );
        }
        
        if (data.timeSeries.margins) {
            charts['margins-trend-chart'] = createLineChart(
                'margins-trend-chart', 
                data.timeSeries.margins,
                formatters.percent
            );
        }
        
        if (data.timeSeries.cashFlow) {
            charts['cashflow-chart'] = createWaterfallChart(
                'cashflow-chart',
                data.timeSeries.cashFlow,
                'Cash Flow'
            );
        }
        
        if (data.planFactDrivers) {
            charts['variance-chart'] = createVarianceChart(
                'variance-chart',
                data.planFactDrivers
            );
        }
        
        if (data.structures.byBranch) {
            charts['revenue-branches-chart'] = createHorizontalBarChart(
                'revenue-branches-chart',
                data.structures.byBranch
            );
        }
        
        // Initialize cash forecast chart (Task 1 - Sprint 5)
        updateCashForecast();
        
        // Initialize EBITDA drivers chart (Task 2 - Sprint 5)
        createEbitdaDriversChart();
        
        // Создание таблиц и компонентов
        if (data.debtors) createDebtorsTable(data.debtors);
        if (data.coefficients) createCoefficientsGrid(data.coefficients);
        if (data.cashAccounts) createAccountsTable(data.cashAccounts);
        
        // Обновление дополнительных элементов
        if (data.coefficients) {
            document.getElementById('dso-value').textContent = data.coefficients.dso;
        }
        document.getElementById('runway-months').textContent = data.kpi.cashRunwayMonths.toFixed(1);
        
        // Отображение алертов
        if (data.alerts) {
            displayAlerts(data.alerts);
        }
        
        // D1: Проверка рекомендаций
        processRecommendations(data);
    }

    // Быстрое обновление waterfall без пересоздания
    function updateWaterfallChart(chartInstance, newData) {
        if (!chartInstance || !chartInstance.data) return false;
        
        const startTime = performance.now();
        
        // Пересчет данных
        const values = [data.opening, ...data.ocf, ...data.icf, ...data.fcf, data.closing];
        const cumulative = [data.opening];
        
        for (let i = 1; i < values.length - 1; i++) {
            cumulative.push(cumulative[i-1] + values[i]);
        }
        cumulative.push(data.closing);
        
        // Обновляем данные без пересоздания
        chartInstance.data.labels = data.labels;
        chartInstance.data.datasets[0].data = values.map((value, index) => {
            if (index === 0 || index === values.length - 1) {
                return value;
            }
            return value;
        });
        chartInstance.data.datasets[1].data = cumulative;
        
        // Быстрое обновление без анимации
        chartInstance.update('none');
        
        const endTime = performance.now();
        const updateTime = endTime - startTime;
        console.log('Waterfall update time: ' + updateTime.toFixed(1) + 'ms');
        
        return updateTime < 50; // Проверка на соответствие requirement
    }

    // Оптимизированная функция рендеринга
    const originalRenderDashboard = renderDashboard;
    renderDashboard = function(data) {
        dashboardData = data;
        
        // Если waterfall уже существует, обновляем его быстро
        if (charts['cashflow-chart'] && data.timeSeries.cashFlow) {
            const updateResult = updateWaterfallChart(charts['cashflow-chart'], data.timeSeries.cashFlow);
            if (!updateResult) {
                console.warn('Waterfall update exceeded 50ms threshold');
            }
            
            // Обновляем остальные компоненты
            updateKPICards(data);
            if (data.debtors) createDebtorsTable(data.debtors);
            if (data.coefficients) createCoefficientsGrid(data.coefficients);
            if (data.cashAccounts) createAccountsTable(data.cashAccounts);
            if (data.coefficients) {
                document.getElementById('dso-value').textContent = data.coefficients.dso;
            }
            document.getElementById('runway-months').textContent = data.kpi.cashRunwayMonths.toFixed(1);
            if (data.alerts) {
                displayAlerts(data.alerts);
            }
        } else {
            // Первичный рендер
            originalRenderDashboard(data);
        }
    };

    // Debug API
    window.__dbg = window.__dbg || {};
    window.__dbg.waterfallDebug = function() {
        const chart = charts['cashflow-chart'];
        if (chart && chart._waterfallDebug) {
            return chart._waterfallDebug();
        }
        return { error: 'Waterfall chart not found or debug not available' };
    };
    
    window.__dbg.varianceDebug = function() {
        const chart = charts['variance-chart'];
        if (chart && chart._varianceCheck) {
            return chart._varianceCheck();
        }
        return { error: 'Variance chart not found or debug not available' };
    };

    // Управление фильтрами
    let currentFilters = {
        company: 'progress',
        organization: 'hq',
        counterparty: 'all',
        manager: 'all',
        periodPreset: 'month',
        dateFrom: '2024-11-01',
        dateTo: '2024-11-30',
        granularity: 'monthly',
        showFact: true,
        showPlan: true,
        showPrevYear: true,
        showForecast: true,
        percentageMode: false
    };

    // Загрузка фильтров из localStorage
    function loadFiltersFromStorage() {
        try {
            const stored = localStorage.getItem('dash.filters');
            if (stored) {
                const parsed = JSON.parse(stored);
                currentFilters = {...currentFilters, ...parsed};
            }
        } catch (error) {
            console.warn('Failed to load filters from storage:', error);
        }
    }

    // Сохранение фильтров в localStorage
    function saveFiltersToStorage() {
        try {
            localStorage.setItem('dash.filters', JSON.stringify(currentFilters));
        } catch (error) {
            console.warn('Failed to save filters to storage:', error);
        }
    }

    // Применение фильтров к интерфейсу
    function applyFiltersToUI() {
        // Обновление селектов
        const selectors = {
            'filter-company': 'company',
            'filter-organization': 'organization', 
            'filter-counterparty': 'counterparty',
            'filter-manager': 'manager',
            'filter-granularity': 'granularity'
        };

        Object.entries(selectors).forEach(([elementId, filterKey]) => {
            const element = document.getElementById(elementId);
            if (element) element.value = currentFilters[filterKey];
        });

        // Обновление дат
        document.getElementById('filter-date-from').value = currentFilters.dateFrom;
        document.getElementById('filter-date-to').value = currentFilters.dateTo;

        // Обновление чекбоксов
        document.getElementById('show-fact').checked = currentFilters.showFact;
        document.getElementById('show-plan').checked = currentFilters.showPlan;
        document.getElementById('show-prev-year').checked = currentFilters.showPrevYear;
        document.getElementById('show-forecast').checked = currentFilters.showForecast;

        // Обновление тумблера
        document.getElementById('toggle-percentage').checked = currentFilters.percentageMode;
        document.getElementById('toggle-mode-label').textContent = 
            currentFilters.percentageMode ? '100%' : 'Абсолют';

        // Обновление активного пресета
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === currentFilters.periodPreset);
        });
    }

    // Быстрое обновление всех графиков (≤100ms)
    function applyFilters() {
        // B2: Performance measurement - applyFilters
        if (window.performance && window.performance.mark) {
            window.performance.mark('applyFilters-start');
        }
        
        const startTime = performance.now();
        
        saveFiltersToStorage();
        
        // Batch update всех графиков без пересоздания инстансов
        const updates = [];
        
        // Обновление графика выручки
        if (charts['revenue-trend-chart']) {
            updates.push(updateRevenueChart(charts['revenue-trend-chart']));
        }
        
        // Обновление графика маржинальности
        if (charts['margins-trend-chart']) {
            updates.push(updateMarginsChart(charts['margins-trend-chart']));
        }
        
        // Обновление графика по направлениям с учетом режима %
        if (charts['revenue-branches-chart']) {
            updates.push(updateBranchesChartWithFilters(charts['revenue-branches-chart']));
        }
        
        // Обновление waterfall при изменении периода
        if (charts['cashflow-chart'] && dashboardData?.timeSeries?.cashFlow) {
            updates.push(updateWaterfallChart(charts['cashflow-chart'], dashboardData.timeSeries.cashFlow));
        }

        // Ждем завершения всех обновлений
        Promise.all(updates).then(() => {
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            
            // B2: Performance measurement end
            if (window.performance && window.performance.mark && window.performance.measure) {
                window.performance.mark('applyFilters-end');
                window.performance.measure('applyFilters', 'applyFilters-start', 'applyFilters-end');
                
                if (window.CFODashboard && window.CFODashboard.log) {
                    window.CFODashboard.log('perf', 'applyFilters', { 
                        duration: updateTime.toFixed(2) + 'ms',
                        targetMs: '≤100ms',
                        passed: updateTime <= 100
                    });
                }
            }
            
            console.log(`Filters applied in ${updateTime.toFixed(1)}ms`);
            
            if (updateTime > 100) {
                console.warn(`Filter update exceeded 100ms threshold: ${updateTime.toFixed(1)}ms`);
            }
        });
        
        return startTime; // Возвращаем для debug
    }

    // Быстрое обновление графика выручки
    function updateRevenueChart(chart) {
        return new Promise((resolve) => {
            if (!chart || !dashboardData?.timeSeries?.revenue) {
                resolve();
                return;
            }

            // Фильтрация серий по чекбоксам
            const datasets = [];
            const data = dashboardData.timeSeries.revenue;
            
            if (currentFilters.showFact && data.fact) {
                datasets.push({
                    label: 'Факт',
                    data: data.fact,
                    borderColor: IBCS_COLORS.fact,
                    backgroundColor: IBCS_COLORS.fact,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    borderWidth: 1
                });
            }
            
            if (currentFilters.showPlan && data.plan) {
                datasets.push({
                    label: 'План',
                    data: data.plan,
                    borderColor: IBCS_COLORS.planBorder,
                    backgroundColor: IBCS_COLORS.plan,
                    fill: false,
                    borderDash: [0],
                    tension: 0.1,
                    pointRadius: 0,
                    borderWidth: 1
                });
            }
            
            if (currentFilters.showPrevYear && data.prevYear) {
                datasets.push({
                    label: 'Прошлый год',
                    data: data.prevYear,
                    borderColor: IBCS_COLORS.prevYear,
                    backgroundColor: IBCS_COLORS.prevYear,
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    borderWidth: 1
                });
            }
            
            if (currentFilters.showForecast && data.forecast) {
                const forecastData = new Array(data.fact.length - data.forecast.length).fill(null)
                    .concat(data.forecast);
                datasets.push({
                    label: 'Прогноз',
                    data: forecastData,
                    borderColor: IBCS_COLORS.forecast,
                    backgroundColor: IBCS_COLORS.forecast,
                    fill: false,
                    borderDash: [5, 5],
                    tension: 0.1,
                    pointRadius: 0,
                    borderWidth: 1
                });
            }

            chart.data.datasets = datasets;
            chart.update('none');
            resolve();
        });
    }

    // Быстрое обновление графика маржинальности
    function updateMarginsChart(chart) {
        return new Promise((resolve) => {
            if (!chart || !dashboardData?.timeSeries?.margins) {
                resolve();
                return;
            }

            const data = dashboardData.timeSeries.margins;
            const datasets = [];
            
            // Показываем только активные серии в соответствии с фильтрами
            if (currentFilters.showFact && data.gross) {
                datasets.push({
                    label: 'Валовая',
                    data: data.gross,
                    borderColor: IBCS_COLORS.fact,
                    backgroundColor: IBCS_COLORS.fact,
                    fill: false
                });
            }
            
            if (currentFilters.showPlan && data.ebitda) {
                datasets.push({
                    label: 'EBITDA',
                    data: data.ebitda,
                    borderColor: IBCS_COLORS.forecast,
                    backgroundColor: IBCS_COLORS.forecast,
                    fill: false
                });
            }
            
            if (currentFilters.showPrevYear && data.net) {
                datasets.push({
                    label: 'Чистая',
                    data: data.net,
                    borderColor: IBCS_COLORS.prevYear,
                    backgroundColor: IBCS_COLORS.prevYear,
                    fill: false
                });
            }

            chart.data.datasets = datasets;
            chart.update('none');
            resolve();
        });
    }

    // Обновление графика направлений с учетом фильтров
    function updateBranchesChartWithFilters(chart) {
        return new Promise((resolve) => {
            if (!chart || !dashboardData?.structures?.byBranch) {
                resolve();
                return;
            }

            const data = dashboardData.structures.byBranch;
            const sortedData = [...data].sort((a, b) => b.revenue - a.revenue);
            
            chart.data.labels = sortedData.map(d => d.name);
            chart.data.datasets[0].data = currentFilters.percentageMode ? 
                sortedData.map(d => d.share) : 
                sortedData.map(d => d.revenue);

            // Обновляем формат оси
            chart.options.scales.x.ticks.callback = function(value) {
                return currentFilters.percentageMode ? 
                    formatters.percent(value) : 
                    formatters.millions(value);
            };

            chart.update('none');
            resolve();
        });
    }

    // Инициализация обработчиков фильтров
    function initializeFilters() {
        loadFiltersFromStorage();
        applyFiltersToUI();

        // Обработчики селектов
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('filter-select') || e.target.classList.contains('filter-input')) {
                const filterId = e.target.id;
                const filterMap = {
                    'filter-company': 'company',
                    'filter-organization': 'organization',
                    'filter-counterparty': 'counterparty',
                    'filter-manager': 'manager',
                    'filter-granularity': 'granularity',
                    'filter-date-from': 'dateFrom',
                    'filter-date-to': 'dateTo'
                };

                if (filterMap[filterId]) {
                    currentFilters[filterMap[filterId]] = e.target.value;
                    applyFilters();
                }
            }
        });

        // Обработчики чекбоксов
        document.addEventListener('change', function(e) {
            if (e.target.type === 'checkbox') {
                const checkboxMap = {
                    'show-fact': 'showFact',
                    'show-plan': 'showPlan',
                    'show-prev-year': 'showPrevYear',
                    'show-forecast': 'showForecast',
                    'toggle-percentage': 'percentageMode'
                };

                if (checkboxMap[e.target.id]) {
                    currentFilters[checkboxMap[e.target.id]] = e.target.checked;
                    
                    if (e.target.id === 'toggle-percentage') {
                        document.getElementById('toggle-mode-label').textContent = 
                            e.target.checked ? '100%' : 'Абсолют';
                    }
                    
                    applyFilters();
                }
            }
        });

        // Обработчики пресетов периода
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('preset-btn')) {
                const preset = e.target.dataset.preset;
                
                // Обновляем активный пресет
                document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                
                currentFilters.periodPreset = preset;
                
                // Устанавливаем соответствующие даты
                const today = new Date();
                let dateFrom, dateTo;
                
                switch (preset) {
                    case 'today':
                        dateFrom = dateTo = today.toISOString().split('T')[0];
                        break;
                    case 'week':
                        dateFrom = new Date(today - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                        dateTo = today.toISOString().split('T')[0];
                        break;
                    case 'month':
                        dateFrom = new Date(today.getFullYear(), today.getMonth(), 1).toISOString().split('T')[0];
                        dateTo = new Date(today.getFullYear(), today.getMonth() + 1, 0).toISOString().split('T')[0];
                        break;
                    case 'quarter':
                        const quarter = Math.floor(today.getMonth() / 3);
                        dateFrom = new Date(today.getFullYear(), quarter * 3, 1).toISOString().split('T')[0];
                        dateTo = new Date(today.getFullYear(), (quarter + 1) * 3, 0).toISOString().split('T')[0];
                        break;
                    case 'year':
                        dateFrom = new Date(today.getFullYear(), 0, 1).toISOString().split('T')[0];
                        dateTo = new Date(today.getFullYear(), 11, 31).toISOString().split('T')[0];
                        break;
                }
                
                currentFilters.dateFrom = dateFrom;
                currentFilters.dateTo = dateTo;
                
                document.getElementById('filter-date-from').value = dateFrom;
                document.getElementById('filter-date-to').value = dateTo;
                
                applyFilters();
            }
        });
    }

    // Легкий валидатор данных без тяжелых библиотек
    function validateData(data, showBanner = true) {
        const errors = [];
        const warnings = [];
        
        try {
            // Базовая валидация структуры
            if (!data || typeof data !== 'object') {
                errors.push('Данные должны быть объектом');
                return { valid: false, errors, warnings };
            }
            
            // Проверка обязательных полей
            const requiredFields = ['meta', 'kpi', 'timeSeries', 'structures'];
            requiredFields.forEach(field => {
                if (!data[field]) {
                    errors.push(`Отсутствует обязательное поле: ${field}`);
                }
            });
            
            // Валидация meta
            if (data.meta) {
                if (data.meta.currency && !['RUB', 'USD', 'EUR'].includes(data.meta.currency)) {
                    warnings.push(`Неизвестная валюта: ${data.meta.currency}`);
                }
            }
            
            // Валидация KPI
            if (data.kpi) {
                const numericFields = ['ebitda', 'ocf', 'cashEnd', 'cashRunwayMonths'];
                numericFields.forEach(field => {
                    if (data.kpi[field] !== undefined && typeof data.kpi[field] !== 'number') {
                        errors.push(`Поле kpi.${field} должно быть числом`);
                    }
                });
                
                // Проверка margins
                if (data.kpi.margins) {
                    ['gross', 'ebitda', 'net'].forEach(margin => {
                        const value = data.kpi.margins[margin];
                        if (value !== undefined) {
                            if (typeof value !== 'number') {
                                errors.push(`kpi.margins.${margin} должно быть числом`);
                            } else if (margin === 'gross' && (value < 0 || value > 100)) {
                                warnings.push(`Валовая маржа вне ожидаемого диапазона: ${value}%`);
                            }
                        }
                    });
                }
            }
            
            // Валидация временных рядов
            if (data.timeSeries) {
                if (data.timeSeries.revenue) {
                    const revenue = data.timeSeries.revenue;
                    ['fact', 'plan', 'prevYear'].forEach(series => {
                        if (revenue[series] && !Array.isArray(revenue[series])) {
                            errors.push(`timeSeries.revenue.${series} должно быть массивом`);
                        } else if (revenue[series]) {
                            revenue[series].forEach((value, index) => {
                                if (typeof value !== 'number') {
                                    warnings.push(`Нечисловое значение в revenue.${series}[${index}]: ${value}`);
                                }
                            });
                        }
                    });
                    
                    // Проверка согласованности длин массивов
                    if (revenue.dates && revenue.fact && revenue.dates.length !== revenue.fact.length) {
                        warnings.push('Несоответствие длины дат и фактических данных выручки');
                    }
                }
            }
            
            // Валидация дебиторов
            if (data.debtors && Array.isArray(data.debtors)) {
                data.debtors.forEach((debtor, index) => {
                    if (!debtor.name) {
                        warnings.push(`Дебитор ${index} без названия`);
                    }
                    if (typeof debtor.amount !== 'number' || debtor.amount < 0) {
                        errors.push(`Неверная сумма дебитора ${debtor.name || index}: ${debtor.amount}`);
                    }
                    if (debtor.bucket && !['0-30', '31-60', '61-90', '90+'].includes(debtor.bucket)) {
                        warnings.push(`Неизвестный bucket для ${debtor.name}: ${debtor.bucket}`);
                    }
                });
            }
            
            // Валидация коэффициентов
            if (data.coefficients) {
                const coeffs = data.coefficients;
                
                // Проверка CCC расчета
                if (coeffs.dso !== undefined && coeffs.dii !== undefined && coeffs.dpo !== undefined && coeffs.ccc !== undefined) {
                    const calculatedCCC = coeffs.dso + (coeffs.dii || 0) - coeffs.dpo;
                    if (Math.abs(calculatedCCC - coeffs.ccc) > 1) {
                        warnings.push(`CCC расчет не сходится: ${coeffs.ccc} vs расчетный ${calculatedCCC.toFixed(1)}`);
                    }
                }
                
                // Проверка разумных диапазонов
                if (coeffs.current !== undefined && (coeffs.current < 0.1 || coeffs.current > 10)) {
                    warnings.push(`Current Ratio вне обычного диапазона: ${coeffs.current}`);
                }
                
                if (coeffs.dso !== undefined && (coeffs.dso < 0 || coeffs.dso > 365)) {
                    warnings.push(`DSO вне разумного диапазона: ${coeffs.dso} дней`);
                }
            }
            
        } catch (error) {
            errors.push(`Ошибка валидации: ${error.message}`);
        }
        
        const valid = errors.length === 0;
        
        // Показываем баннер с ошибками если есть
        if (showBanner && !valid) {
            showValidationBanner(errors, warnings);
        }
        
        return { valid, errors, warnings };
    }
    
    // Показ баннера валидации
    function showValidationBanner(errors, warnings) {
        // Удаляем предыдущий баннер если есть
        const existingBanner = document.getElementById('validation-banner');
        if (existingBanner) {
            existingBanner.remove();
        }
        
        const banner = document.createElement('div');
        banner.id = 'validation-banner';
        banner.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            padding: 12px 20px;
            z-index: 10000;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const content = [];
        if (errors.length > 0) {
            content.push(`❌ ${errors.length} ошибок: ${errors.slice(0, 2).join(', ')}${errors.length > 2 ? '...' : ''}`);
        }
        if (warnings.length > 0) {
            content.push(`⚠️ ${warnings.length} предупреждений`);
        }
        
        banner.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>${content.join(' | ')}</div>
                <button class="banner-close" style="background: none; border: none; color: white; cursor: pointer; font-size: 16px; padding: 0 4px;">✕</button>
            </div>
        `;
        
        document.body.appendChild(banner);

        banner.querySelector('.banner-close').addEventListener('click', () => banner.remove());

        // Автоскрытие через 10 секунд
        setTimeout(() => {
            if (document.getElementById('validation-banner')) {
                banner.remove();
            }
        }, 10000);
        
        // Логирование в консоль для отладки
        console.group('Data Validation Results');
        if (errors.length > 0) {
            console.error('Errors:', errors);
        }
        if (warnings.length > 0) {
            console.warn('Warnings:', warnings);
        }
        console.groupEnd();
    }

    // Экспорт в PNG с поддержкой отдельных страниц (Sprint 4)
    function exportDashboardToPNG(pageId = null) {
        return new Promise((resolve) => {
            try {
                // B2: Performance measurement - PNG export
                if (window.performance && window.performance.mark) {
                    window.performance.mark('exportPNG-start');
                }
                const exportStartTime = performance.now();
                
                // Определяем, что экспортировать: всю дашборд или конкретную страницу
                const targetPageId = pageId || currentPage;
                const isFullDashboard = !pageId;
                
                let exportElement;
                let exportName;
                
                if (isFullDashboard) {
                    // Экспортируем весь дашборд
                    exportElement = document.getElementById('dashboard');
                    exportName = 'CFO Dashboard - Full';
                } else {
                    // Экспортируем конкретную страницу
                    exportElement = document.getElementById(`page-${targetPageId}`);
                    exportName = `CFO Dashboard - ${PAGE_DEFINITIONS[targetPageId]?.name || targetPageId}`;
                }
                
                if (!exportElement) {
                    resolve({ 
                        success: false, 
                        message: isFullDashboard ? 'Dashboard element not found' : `Page ${targetPageId} not found` 
                    });
                    return;
                }
                
                // Создаем canvas размером с целевой элемент
                const canvas = document.createElement('canvas');
                const rect = exportElement.getBoundingClientRect();
                const scale = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * scale;
                canvas.height = rect.height * scale;
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                
                const ctx = canvas.getContext('2d');
                ctx.scale(scale, scale);
                
                // Белый фон
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, rect.width, rect.height);
                
                // Рендерим заголовок страницы для отдельных страниц
                if (!isFullDashboard) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 24px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                    ctx.textAlign = 'center';
                    ctx.fillText(exportName, rect.width / 2, 40);
                    
                    // Подзаголовок с датой
                    ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                    ctx.fillStyle = '#7f8c8d';
                    const dateStr = new Date().toLocaleDateString('ru-RU');
                    ctx.fillText(`Экспорт от ${dateStr}`, rect.width / 2, 65);
                }
                
                // Получаем все canvas элементы внутри экспортируемого элемента
                const canvasElements = exportElement.querySelectorAll('canvas');
                const promises = Array.from(canvasElements).map(sourceCanvas => {
                    return new Promise(canvasResolve => {
                        if (sourceCanvas.width === 0 || sourceCanvas.height === 0) {
                            canvasResolve();
                            return;
                        }
                        
                        const sourceRect = sourceCanvas.getBoundingClientRect();
                        const targetRect = exportElement.getBoundingClientRect();
                        
                        // Вычисляем позицию canvas относительно экспортируемого элемента
                        const relativeX = sourceRect.left - targetRect.left;
                        const relativeY = sourceRect.top - targetRect.top;
                        
                        try {
                            // Копируем содержимое canvas
                            ctx.drawImage(sourceCanvas, relativeX, relativeY);
                            canvasResolve();
                        } catch (err) {
                            console.warn('Failed to copy canvas:', err);
                            canvasResolve();
                        }
                    });
                });
                
                // Ждем завершения рендеринга всех canvas
                Promise.all(promises).then(() => {
                    const dataURL = canvas.toDataURL('image/png');
                    
                    // B2: Performance measurement end
                    const exportEndTime = performance.now();
                    const exportDuration = exportEndTime - exportStartTime;
                    
                    if (window.performance && window.performance.mark && window.performance.measure) {
                        window.performance.mark('exportPNG-end');
                        window.performance.measure('exportPNG', 'exportPNG-start', 'exportPNG-end');
                        
                        if (window.CFODashboard && window.CFODashboard.log) {
                            window.CFODashboard.log('perf', 'exportPNG', { 
                                pageId: targetPageId,
                                duration: exportDuration.toFixed(2) + 'ms',
                                targetMs: 'no specific target',
                                passed: true
                            });
                        }
                    }
                    
                    resolve({
                        success: true,
                        message: `${exportName} exported successfully`,
                        dataURL: dataURL,
                        width: rect.width,
                        height: rect.height,
                        pageId: targetPageId,
                        pageName: exportName,
                        timestamp: new Date().toISOString(),
                        isFullDashboard: isFullDashboard,
                        exportTime: exportDuration.toFixed(2) + 'ms'
                    });
                }).catch(error => {
                    console.error('Error during canvas rendering:', error);
                    // Fallback - возвращаем хотя бы базовый canvas
                    const dataURL = canvas.toDataURL('image/png');
                    resolve({
                        success: true,
                        message: `${exportName} exported with limited content`,
                        dataURL: dataURL,
                        width: rect.width,
                        height: rect.height,
                        pageId: targetPageId,
                        pageName: exportName,
                        timestamp: new Date().toISOString(),
                        isFullDashboard: isFullDashboard,
                        warning: 'Some chart content may be missing'
                    });
                });
                
            } catch (error) {
                resolve({ 
                    success: false, 
                    message: error.message,
                    fallback: 'Use browser print function: Ctrl+P -> Save as PDF -> Convert to PNG'
                });
            }
        });
    }

    // Система навигации по страницам (Sprint 4)
    let currentPage = 'overview';
    let pageWidgets = {}; // Кэш виджетов по страницам
    
    const PAGE_DEFINITIONS = {
        overview: {
            name: 'Обзор', 
            widgets: ['revenue-trend-chart', 'margins-trend-chart', 'cashflow-chart', 'variance-chart']
        },
        sales: {
            name: 'Продажи',
            widgets: ['branches-sales-chart', 'organizations-sales-table', 'managers-sales-table', 'avg-check-chart']
        },
        profit: {
            name: 'Прибыльность',
            widgets: ['margin-branches-chart', 'ebitda-bridge-chart', 'opex-categories-chart', 'profit-trends-chart']
        },
        cash: {
            name: 'Ликвидность',
            widgets: ['cashflow-bridge-chart', 'accounts-detailed-table', 'runway-forecast-chart', 'weekly-forecast-chart']
        },
        ar: {
            name: 'Дебиторка',
            widgets: ['debtors-detailed-table', 'aging-analysis-chart', 'dso-trends-chart', 'reserves-table']
        }
    };

    // Хеш-роутер для deep linking
    function initializeRouter() {
        // Читаем хеш при загрузке
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // убираем #
            if (hash && hash.startsWith('/')) {
                const [pageId, queryString] = hash.slice(1).split('?');
                
                if (PAGE_DEFINITIONS[pageId]) {
                    setPage(pageId, false); // false = не обновлять хеш
                    
                    // Handle query parameters for cash forecast scenarios
                    if (pageId === 'cash' && queryString) {
                        const params = new URLSearchParams(queryString);
                        const scenario = params.get('scenario');
                        
                        if (scenario && ['base', 'optimistic', 'pessimistic'].includes(scenario)) {
                            // Set scenario after a short delay to ensure page is loaded
                            setTimeout(() => {
                                currentForecastScenario = scenario;
                                document.querySelectorAll('.scenario-btn').forEach(btn => {
                                    btn.classList.toggle('active', btn.dataset.scenario === scenario);
                                });
                                updateCashForecast();
                            }, 50);
                        }
                    }
                }
            }
        }

        // Обработчик изменения хеша
        window.addEventListener('hashchange', handleHashChange);
        
        // Проверяем при загрузке
        handleHashChange();
        
        // Если нет хеша, устанавливаем дефолтный
        if (!window.location.hash) {
            window.location.hash = '#/overview';
        }
    }

    // Переключение страницы с анимацией ≤25ms
    function setPage(pageId, updateHash = true) {
        if (!PAGE_DEFINITIONS[pageId] || pageId === currentPage) return false;

        // B2: Performance measurement - page switch
        if (window.performance && window.performance.mark) {
            window.performance.mark('pageSwitch-start');
        }

        const startTime = performance.now();

        // Обновляем хеш URL
        if (updateHash) {
            window.location.hash = '#/' + pageId;
        }

        // Сохраняем в localStorage
        currentPage = pageId;
        localStorage.setItem('dash.page', pageId);

        // Переключаем активные табы
        document.querySelectorAll('.segment-tab').forEach(tab => {
            const isActive = tab.dataset.page === pageId;
            tab.classList.toggle('active', isActive);
            tab.setAttribute('aria-selected', isActive);
            tab.setAttribute('tabindex', isActive ? '0' : '-1');
            
            if (isActive) {
                tab.setAttribute('aria-current', 'page');
            } else {
                tab.removeAttribute('aria-current');
            }
        });

        // Переключаем страницы контента
        document.querySelectorAll('.page-content').forEach(page => {
            const isActive = page.id === 'page-' + pageId;
            
            if (isActive) {
                page.style.display = 'block';
                // Принудительный reflow для корректной анимации
                page.offsetHeight;
                page.classList.add('active');
                
                // Активируем виджеты этой страницы
                mountPageWidgets(pageId);
                
                // C1: Фокус уходит в первый виджет страницы
                setTimeout(() => {
                    const firstFocusable = page.querySelector('button, [tabindex="0"], canvas, .chart-container');
                    if (firstFocusable) {
                        firstFocusable.focus();
                    }
                }, 150);
            } else {
                page.classList.remove('active');
                
                // Через короткую задержку скрываем неактивные страницы
                setTimeout(() => {
                    if (!page.classList.contains('active')) {
                        page.style.display = 'none';
                        unmountPageWidgets(page.id.replace('page-', ''));
                    }
                }, 200);
            }
        });

        const endTime = performance.now();
        const switchTime = endTime - startTime;
        
        // B2: Performance measurement end
        if (window.performance && window.performance.mark && window.performance.measure) {
            window.performance.mark('pageSwitch-end');
            window.performance.measure('pageSwitch', 'pageSwitch-start', 'pageSwitch-end');
            
            if (window.CFODashboard && window.CFODashboard.log) {
                window.CFODashboard.log('perf', 'pageSwitch', { 
                    pageId: pageId,
                    duration: switchTime.toFixed(2) + 'ms',
                    targetMs: '≤25ms',
                    passed: switchTime <= 25
                });
            }
        }
        
        console.log(`Page switch to ${pageId}: ${switchTime.toFixed(1)}ms`);
        
        if (switchTime > 25) {
            console.warn(`Page switch exceeded 25ms target: ${switchTime.toFixed(1)}ms`);
        }

        return true;
    }

    // Активация виджетов страницы (mount)
    function mountPageWidgets(pageId) {
        const widgets = PAGE_DEFINITIONS[pageId].widgets;
        
        widgets.forEach(widgetId => {
            // Если виджет уже создан, просто обновляем
            if (pageWidgets[widgetId]) {
                if (pageWidgets[widgetId].update) {
                    pageWidgets[widgetId].update();
                }
            } else {
                // Создаем новый виджет
                createPageWidget(widgetId, pageId);
            }
        });
    }

    // Деактивация виджетов страницы (unmount)
    function unmountPageWidgets(pageId) {
        const widgets = PAGE_DEFINITIONS[pageId]?.widgets || [];
        
        widgets.forEach(widgetId => {
            if (pageWidgets[widgetId]) {
                // Переводим в спящий режим, не удаляем полностью
                if (pageWidgets[widgetId].sleep) {
                    pageWidgets[widgetId].sleep();
                }
            }
        });
    }

    // Создание виджета для конкретной страницы
    function createPageWidget(widgetId, pageId) {
        try {
            // В зависимости от типа виджета создаем нужный компонент
            if (widgetId.includes('chart')) {
                pageWidgets[widgetId] = createChartWidget(widgetId, pageId);
            } else if (widgetId.includes('table')) {
                pageWidgets[widgetId] = createTableWidget(widgetId, pageId);
            }
        } catch (error) {
            console.warn(`Failed to create widget ${widgetId}:`, error);
        }
    }

    // Инициализация навигации
    function initializePageNavigation() {
        // Загружаем сохраненную страницу
        const savedPage = localStorage.getItem('dash.page');
        if (savedPage && PAGE_DEFINITIONS[savedPage]) {
            currentPage = savedPage;
        }

        // Обработчики кликов по табам
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('segment-tab')) {
                const pageId = e.target.dataset.page;
                if (pageId) {
                    setPage(pageId);
                }
            }
        });

        // Клавиатурная навигация по табам
        document.addEventListener('keydown', function(e) {
            if (e.target.classList.contains('segment-tab')) {
                const tabs = Array.from(document.querySelectorAll('.segment-tab'));
                const currentIndex = tabs.indexOf(e.target);
                let targetIndex = currentIndex;

                if (e.key === 'ArrowLeft') {
                    targetIndex = currentIndex > 0 ? currentIndex - 1 : tabs.length - 1;
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    targetIndex = currentIndex < tabs.length - 1 ? currentIndex + 1 : 0;
                    e.preventDefault();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    setPage(e.target.dataset.page);
                    e.preventDefault();
                    return;
                }

                if (targetIndex !== currentIndex) {
                    tabs[targetIndex].focus();
                }
            }
        });

        // Инициализируем роутер
        initializeRouter();
        
        // Устанавливаем начальную страницу
        if (!window.location.hash) {
            setPage(currentPage);
        }
    }

    // API методы для навигации (Tasks 2)
    function getPage() {
        return currentPage;
    }

    // Система плотности компонентов (Task 4)
    let currentDensity = 'comfort';

    function setDensity(density) {
        if (!['comfort', 'compact'].includes(density)) {
            console.warn('Invalid density:', density);
            return false;
        }

        currentDensity = density;
        
        // Применяем класс к dashboard
        const dashboard = document.getElementById('dashboard');
        dashboard.classList.remove('density-comfort', 'density-compact');
        dashboard.classList.add('density-' + density);

        // Сохраняем в localStorage
        localStorage.setItem('dash.density', density);

        // Обновляем селектор
        const selector = document.getElementById('density-selector');
        if (selector) {
            selector.value = density;
        }

        console.log(`Density changed to: ${density}`);
        return true;
    }

    function initializeDensity() {
        // Загружаем сохраненную плотность
        const savedDensity = localStorage.getItem('dash.density');
        if (savedDensity && ['comfort', 'compact'].includes(savedDensity)) {
            currentDensity = savedDensity;
        }

        // Применяем начальную плотность
        setDensity(currentDensity);

        // Обработчик изменения
        document.addEventListener('change', function(e) {
            if (e.target.id === 'density-selector') {
                setDensity(e.target.value);
            }
        });
    }

    // Инициализация клавиатурной навигации для доступности
    function initializeKeyboardNavigation() {
        // Добавляем tabindex для всех интерактивных элементов
        const interactiveElements = [
            '.filter-select', '.filter-input', '.preset-btn', 
            '.toggle-btn', '.severity-filter-btn', '.alerts-bell'
        ];
        
        interactiveElements.forEach(selector => {
            document.querySelectorAll(selector).forEach((element, index) => {
                if (!element.hasAttribute('tabindex')) {
                    element.setAttribute('tabindex', '0');
                }
            });
        });

        // Добавляем ARIA labels для лучшей доступности
        const alertsBell = document.getElementById('alerts-bell');
        if (alertsBell) {
            alertsBell.setAttribute('aria-label', 'Открыть панель алертов');
            alertsBell.setAttribute('role', 'button');
        }

        // Клавиатурные обработчики
        document.addEventListener('keydown', function(e) {
            // C1: Горячие клавиши ←/→ для переключения страниц
            if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && !e.target.matches('input, select, textarea')) {
                e.preventDefault();
                const pageIds = Object.keys(PAGE_DEFINITIONS);
                const currentIndex = pageIds.indexOf(currentPage);
                let newIndex;
                
                if (e.key === 'ArrowLeft') {
                    newIndex = currentIndex > 0 ? currentIndex - 1 : pageIds.length - 1;
                } else {
                    newIndex = currentIndex < pageIds.length - 1 ? currentIndex + 1 : 0;
                }
                
                setPage(pageIds[newIndex]);
            }
            
            // Escape для закрытия панели алертов
            if (e.key === 'Escape') {
                const panel = document.getElementById('alerts-panel');
                if (panel && panel.classList.contains('open')) {
                    toggleAlertsPanel(false);
                }
            }

            // Enter/Space для активации кнопок
            if (e.key === 'Enter' || e.key === ' ') {
                const focused = document.activeElement;
                
                if (focused.classList.contains('preset-btn')) {
                    e.preventDefault();
                    focused.click();
                }
                
                if (focused.classList.contains('alerts-bell')) {
                    e.preventDefault();
                    toggleAlertsPanel();
                }
                
                if (focused.classList.contains('alert-action-btn')) {
                    e.preventDefault();
                    focused.click();
                }
            }
        });

        // Добавляем пропуск к основному содержимому
        const skipLink = document.createElement('a');
        skipLink.href = '#dashboard';
        skipLink.className = 'sr-only';
        skipLink.style.cssText = `
            position: absolute;
            top: -40px;
            left: 6px;
            background: #007aff;
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
            z-index: 10001;
            transition: top 0.15s ease;
        `;
        skipLink.textContent = 'Перейти к основному содержимому';
        skipLink.addEventListener('focus', function() {
            this.style.top = '6px';
        });
        skipLink.addEventListener('blur', function() {
            this.style.top = '-40px';
        });
        
        document.body.insertBefore(skipLink, document.body.firstChild);
    }

    // D1: Система рекомендаций - умные подсказки
    const recommendationRules = [
        {
            id: 'ccc_high',
            check: (data) => (data.coefficients?.ccc || 0) > 45,
            title: 'Цикл оборотных средств высокий',
            message: 'CCC составляет {ccc} дн. (> 45). Проверьте DSO ({dso} дн.) и DPO ({dpo} дн.) для оптимизации.',
            targetPage: 'ar',
            severity: 'high'
        },
        {
            id: 'quick_ratio_low', 
            check: (data) => {
                const quick = data.coefficients?.quickRatio || 0;
                const current = data.coefficients?.currentRatio || 0;
                return quick > 0 && current > 0 && quick < current && (current - quick) > 0.3;
            },
            title: 'Коэффициенты ликвидности', 
            message: 'Quick Ratio меньше Current Ratio на {diff}. Проверьте классификацию запасов и их оборачиваемость.',
            targetPage: 'cash',
            severity: 'medium'
        },
        {
            id: 'cash_runway_critical',
            check: (data) => (data.kpi?.cashRunwayMonths || 0) < 6,
            title: 'Критический уровень ликвидности',
            message: 'Cash Runway: {runway} мес. (< 6 мес.). Необходим план по улучшению денежного потока.',
            targetPage: 'cash',
            severity: 'critical'
        },
        {
            id: 'dso_high',
            check: (data) => (data.coefficients?.dso || 0) > 60,
            title: 'Высокая дебиторская задолженность',
            message: 'DSO составляет {dso} дн. (> 60). Усильте работу с просроченной задолженностью.',
            targetPage: 'ar',
            severity: 'high'
        },
        {
            id: 'bank_concentration',
            check: (data) => {
                const accounts = data.cashAccounts || [];
                const maxConcentration = Math.max(...accounts.map(acc => acc.concentration || 0));
                return maxConcentration > 60;
            },
            title: 'Концентрация банковских средств',
            message: 'Максимальная концентрация в одном банке: {concentration}% (> 60%). Диверсифицируйте риски.',
            targetPage: 'cash',
            severity: 'medium'
        }
    ];

    function checkRecommendations(data) {
        if (!data) return [];
        
        return recommendationRules.filter(rule => {
            try {
                return rule.check(data);
            } catch (e) {
                console.warn('Recommendation rule check failed:', rule.id, e);
                return false;
            }
        }).sort((a, b) => {
            const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
            return severityOrder[a.severity] - severityOrder[b.severity];
        });
    }

    function formatRecommendationMessage(rule, data) {
        let message = rule.message;
        
        // Заменяем плейсхолдеры значениями
        message = message.replace('{ccc}', Math.round(data.coefficients?.ccc || 0));
        message = message.replace('{dso}', Math.round(data.coefficients?.dso || 0));
        message = message.replace('{dpo}', Math.round(data.coefficients?.dpo || 0));
        message = message.replace('{runway}', (data.kpi?.cashRunwayMonths || 0).toFixed(1));
        
        const quick = data.coefficients?.quickRatio || 0;
        const current = data.coefficients?.currentRatio || 0;
        message = message.replace('{diff}', Math.abs(current - quick).toFixed(1));
        
        const accounts = data.cashAccounts || [];
        const maxConcentration = Math.max(...accounts.map(acc => acc.concentration || 0));
        message = message.replace('{concentration}', Math.round(maxConcentration));
        
        return message;
    }

    function showRecommendationBanner(rule, data) {
        const banner = document.getElementById('recommendations-banner');
        const textElement = document.getElementById('recommendation-text');
        const detailsBtn = document.getElementById('recommendation-details');
        
        if (!banner || !textElement || !detailsBtn) return;
        
        // Проверяем, не скрыто ли на сегодня
        const snoozedKey = 'rec_snoozed_' + rule.id;
        const snoozedUntil = localStorage.getItem(snoozedKey);
        const today = new Date().toDateString();
        
        if (snoozedUntil === today) {
            return; // Скрыто на сегодня
        }
        
        textElement.textContent = formatRecommendationMessage(rule, data);
        
        // Настраиваем кнопку "Подробнее"
        detailsBtn.addEventListener('click', () => {
            hideRecommendationBanner();
            if (rule.targetPage) {
                setPage(rule.targetPage);
            }
        }, { once: true });
        
        // Сохраняем текущее правило
        banner.dataset.currentRule = rule.id;
        
        // Показываем баннер
        banner.classList.add('show');
        
        // Автоскрытие через 15 секунд
        setTimeout(() => {
            if (banner.classList.contains('show')) {
                hideRecommendationBanner();
            }
        }, 15000);
    }

    function hideRecommendationBanner() {
        const banner = document.getElementById('recommendations-banner');
        if (banner) {
            banner.classList.remove('show');
        }
    }

    function snoozeRecommendationBanner() {
        const banner = document.getElementById('recommendations-banner');
        const ruleId = banner?.dataset.currentRule;
        
        if (ruleId) {
            const snoozedKey = 'rec_snoozed_' + ruleId;
            const today = new Date().toDateString();
            localStorage.setItem(snoozedKey, today);
        }
        
        hideRecommendationBanner();
    }

    function processRecommendations(data) {
        const recommendations = checkRecommendations(data);
        
        if (recommendations.length > 0) {
            // Показываем самую важную рекомендацию
            setTimeout(() => {
                showRecommendationBanner(recommendations[0], data);
            }, 2000); // Задержка 2 сек после загрузки
        }
    }

    // D2: Версионирование схемы и миграция данных
    const CURRENT_SCHEMA_VERSION = '3.0.0';
    
    const schemaMigrations = {
        '1.0.0': function(data) {
            // Миграция с версии 1.0.0 на 2.0.0
            console.log('Migrating from 1.0.0 to 2.0.0');
            
            // Добавляем новые поля, введенные в 2.0.0
            if (!data.coefficients) {
                data.coefficients = {
                    dso: 47,
                    dpo: 32, 
                    dii: 28,
                    ccc: 43
                };
            }
            
            // Переименовываем старые поля
            if (data.cash && !data.kpi.cashEnd) {
                data.kpi.cashEnd = data.cash;
                delete data.cash;
            }
            
            data.meta.schemaVersion = '2.0.0';
            return data;
        },
        
        '2.0.0': function(data) {
            // Миграция с версии 2.0.0 на 3.0.0
            console.log('Migrating from 2.0.0 to 3.0.0');
            
            // Новые поля в 3.0.0: cashAccounts, планы по кварталам
            if (!data.cashAccounts) {
                data.cashAccounts = [
                    {
                        bank: 'Сбербанк',
                        available: data.kpi.cashEnd * 0.7,
                        blocked: 0,
                        concentration: 70
                    },
                    {
                        bank: 'ВТБ', 
                        available: data.kpi.cashEnd * 0.3,
                        blocked: 0,
                        concentration: 30
                    }
                ];
            }
            
            // Добавляем поддержку прогнозов в timeSeries
            if (data.timeSeries && data.timeSeries.revenue && !data.timeSeries.revenue.forecast) {
                data.timeSeries.revenue.forecast = data.timeSeries.revenue.fact.map(v => v * 1.1);
            }
            
            data.meta.schemaVersion = '3.0.0';
            return data;
        }
    };
    
    function migrateData(data) {
        if (!data || !data.meta) {
            console.warn('Data has no meta field, assuming current version');
            return data;
        }
        
        let currentVersion = data.meta.schemaVersion || '1.0.0';
        const targetVersion = CURRENT_SCHEMA_VERSION;
        
        if (currentVersion === targetVersion) {
            return data; // Уже актуальная версия
        }
        
        console.log(`Migrating data from ${currentVersion} to ${targetVersion}`);
        
        // Применяем миграции последовательно
        const migrationKeys = Object.keys(schemaMigrations).sort();
        let migratedData = JSON.parse(JSON.stringify(data)); // Deep copy
        
        for (const version of migrationKeys) {
            if (compareVersions(currentVersion, version) < 0 && compareVersions(version, targetVersion) <= 0) {
                try {
                    migratedData = schemaMigrations[version](migratedData);
                    
                    // Логируем миграцию
                    if (window.CFODashboard && window.CFODashboard.log) {
                        window.CFODashboard.log('info', 'data_migration', {
                            from: currentVersion,
                            to: migratedData.meta.schemaVersion,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    currentVersion = migratedData.meta.schemaVersion;
                } catch (error) {
                    console.error(`Failed to migrate from version ${version}:`, error);
                    break;
                }
            }
        }
        
        return migratedData;
    }
    
    function compareVersions(a, b) {
        const aParts = a.split('.').map(Number);
        const bParts = b.split('.').map(Number);
        
        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
            const aPart = aParts[i] || 0;
            const bPart = bParts[i] || 0;
            
            if (aPart < bPart) return -1;
            if (aPart > bPart) return 1;
        }
        
        return 0;
    }
    
    function checkSchemaVersion(data) {
        if (!data || !data.meta) return { compatible: true };
        
        const dataVersion = data.meta.schemaVersion || '1.0.0';
        const currentVersion = CURRENT_SCHEMA_VERSION;
        
        const comparison = compareVersions(dataVersion, currentVersion);
        
        if (comparison === 0) {
            return { compatible: true, message: 'Schema version matches' };
        } else if (comparison < 0) {
            return { 
                compatible: true, 
                requiresMigration: true,
                message: `Data version ${dataVersion} is older than current ${currentVersion}. Migration available.`
            };
        } else {
            return {
                compatible: false,
                message: `Data version ${dataVersion} is newer than supported ${currentVersion}. Update dashboard.`
            };
        }
    }
    
    function showSchemaVersionWarning(message) {
        // Показываем предупреждение через error boundary
        if (window.errorBoundary) {
            window.errorBoundary.reportError(new Error(message), 'Schema version mismatch');
        } else {
            console.warn('Schema version warning:', message);
        }
    }

    // API для 1С (A2: JSDoc контракты)
    /**
     * @namespace external1C
     * @description Main API for 1C integration
     */
    window.external1C = {
        /**
         * @method setFilters
         * @description Set dashboard filters from 1C
         * @param {string|Object} filtersJSON - JSON string or object with filter values
         * @returns {Object} Result object with success status and message
         * @example external1C.setFilters('{"company": "progress", "dateFrom": "2024-01-01"}')
         */
        setFilters: function(filtersJSON) {
            try {
                const filters = typeof filtersJSON === 'string' ? JSON.parse(filtersJSON) : filtersJSON;
                currentFilters = {...currentFilters, ...filters};
                applyFiltersToUI();
                applyFilters();
                return { success: true, message: 'Filters applied successfully' };
            } catch (error) {
                console.error('Error setting filters:', error);
                return { success: false, message: error.message };
            }
        },

        getFilters: function() {
            try {
                return JSON.stringify(currentFilters);
            } catch (error) {
                console.error('Error getting filters:', error);
                return JSON.stringify({});
            }
        },

        setPage: function(pageId) {
            try {
                const result = setPage(pageId);
                return { 
                    success: result, 
                    message: result ? `Switched to page: ${pageId}` : `Invalid page: ${pageId}`,
                    currentPage: getPage()
                };
            } catch (error) {
                console.error('Error setting page:', error);
                return { success: false, message: error.message };
            }
        },

        getPage: function() {
            try {
                return getPage();
            } catch (error) {
                console.error('Error getting page:', error);
                return 'overview';
            }
        },

        exportPNG: function(pageId = null) {
            try {
                // Экспорт дашборда полностью или конкретной страницы (Sprint 4)
                return exportDashboardToPNG(pageId);
            } catch (error) {
                console.error('Error exporting PNG:', error);
                return { success: false, message: error.message };
            }
        },

        /**
         * @method setForecastParams 
         * @description Set cash forecast parameters for scenario modeling
         * @param {string|Object} paramsJSON - Forecast parameters with scenario weights, seasonal adjustment flags
         * @returns {Object} Result object with success status
         * @example external1C.setForecastParams('{"scenarioWeights": {"base": 1.0, "optimistic": 1.15}}')
         */
        setForecastParams: function(paramsJSON) {
            try {
                const params = typeof paramsJSON === 'string' ? JSON.parse(paramsJSON) : paramsJSON;
                window._cashForecastParams = {...(window._cashForecastParams || {}), ...params};
                updateCashForecast();
                return { success: true, message: 'Forecast parameters updated successfully' };
            } catch (error) {
                console.error('Error setting forecast params:', error);
                return { success: false, message: error.message };
            }
        },

        getForecastParams: function() {
            try {
                return JSON.stringify(window._cashForecastParams || {});
            } catch (error) {
                console.error('Error getting forecast params:', error);
                return JSON.stringify({});
            }
        },

        /**
         * @method setRole
         * @description Set user role preset (CEO/CFO/Sales) with automatic UI adjustments
         * @param {string} role - User role: "CEO", "CFO", or "Sales"
         * @returns {Object} Result object with success status and current role
         * @example external1C.setRole('CFO') // Sets CFO preset: cash page start, expanded alerts
         */
        setRole: function(role) {
            try {
                if (!['CEO', 'CFO', 'Sales'].includes(role)) {
                    return { success: false, message: `Invalid role: ${role}. Must be CEO, CFO, or Sales.` };
                }
                
                applyRolePreset(role);
                localStorage.setItem('dash.role', role);
                
                return { success: true, message: `Role set to ${role} successfully`, currentRole: role };
            } catch (error) {
                console.error('Error setting role:', error);
                return { success: false, message: error.message };
            }
        },

        getRole: function() {
            try {
                return localStorage.getItem('dash.role') || 'CEO';
            } catch (error) {
                console.error('Error getting role:', error);
                return 'CEO';
            }
        },

        exportCurrentPagePNG: function() {
            try {
                // Экспорт только текущей активной страницы
                return exportDashboardToPNG(currentPage);
            } catch (error) {
                console.error('Error exporting current page PNG:', error);
                return { success: false, message: error.message };
            }
        },

        exportAllPagesPNG: function() {
            try {
                // Экспорт всех страниц по отдельности
                const pageIds = Object.keys(PAGE_DEFINITIONS);
                const exports = {};
                
                const promises = pageIds.map(pageId => {
                    return exportDashboardToPNG(pageId).then(result => {
                        exports[pageId] = result;
                        return result;
                    });
                });
                
                return Promise.all(promises).then(() => {
                    return {
                        success: true,
                        message: 'All pages exported successfully',
                        exports: exports,
                        timestamp: new Date().toISOString()
                    };
                }).catch(error => {
                    return {
                        success: false,
                        message: 'Failed to export some pages',
                        error: error.message,
                        exports: exports
                    };
                });
            } catch (error) {
                console.error('Error exporting all pages PNG:', error);
                return Promise.resolve({ success: false, message: error.message });
            }
        },

        getKPISnapshot: function() {
            try {
                if (!dashboardData) {
                    return JSON.stringify({ error: 'No data available' });
                }
                
                const snapshot = {
                    timestamp: new Date().toISOString(),
                    period: dashboardData.meta?.period || currentFilters.dateFrom + ' - ' + currentFilters.dateTo,
                    company: dashboardData.meta?.company || currentFilters.company,
                    
                    // Ключевые KPI
                    kpi: {
                        revenue: dashboardData.kpi?.revenue?.current || 0,
                        ebitda: dashboardData.kpi?.ebitda || 0,
                        ocf: dashboardData.kpi?.ocf || 0,
                        cashEnd: dashboardData.kpi?.cashEnd || 0,
                        cashRunwayMonths: dashboardData.kpi?.cashRunwayMonths || 0,
                        margins: dashboardData.kpi?.margins || {}
                    },
                    
                    // Финансовые коэффициенты
                    coefficients: {
                        dso: dashboardData.coefficients?.dso || 0,
                        dpo: dashboardData.coefficients?.dpo || 0,
                        dii: dashboardData.coefficients?.dii || 0,
                        ccc: dashboardData.coefficients?.ccc || 0,
                        current: dashboardData.coefficients?.current || 0,
                        quick: dashboardData.coefficients?.quick || 0,
                        debtEbitda: dashboardData.coefficients?.debtEbitda || 0,
                        interestCoverage: dashboardData.coefficients?.interestCoverage || 0
                    },
                    
                    // Активные алерты
                    alerts: filterAlerts(dashboardData.alerts || []).map(alert => ({
                        type: alert.type,
                        severity: alert.severity,
                        message: alert.message,
                        value: alert.value
                    })),
                    
                    // Cash forecast snapshot (Task 1 - Sprint 5)
                    cashForecast: {
                        scenario: currentForecastScenario,
                        forecastWeeks: 8,
                        projectedBalance: charts['weekly-forecast-chart']?.data?.datasets?.[0]?.data?.slice(-1)?.[0] || 0,
                        parameters: window._cashForecastParams || {}
                    },
                    
                    // Дополнительные метрики
                    additional: {
                        totalDebtors: dashboardData.debtors?.length || 0,
                        totalAR: dashboardData.debtors?.reduce((sum, d) => sum + d.amount, 0) || 0,
                        overdueAR: dashboardData.debtors?.filter(d => d.daysOverdue > 0).length || 0,
                        bankAccounts: dashboardData.cashAccounts?.length || 0,
                        maxBankConcentration: Math.max(...(dashboardData.cashAccounts?.map(acc => acc.concentration) || [0]))
                    },
                    
                    // Формулы для справки
                    formulas: {
                        DSO: "DSO = (Дебиторская задолженность / Выручка) × 365",
                        DPO: "DPO = (Кредиторская задолженность / COGS) × 365", 
                        DII: "DII = (Запасы / COGS) × 365",
                        CCC: "CCC = DSO + DII - DPO",
                        "Cash Runway": "Cash Runway = Остаток денег / |Среднемесячный OCF|"
                    },
                    
                    // B2: Performance metrics резюме
                    performance: {
                        recentMeasures: window.performance ? 
                            window.performance.getEntriesByType('measure').slice(-10).map(m => ({
                                name: m.name,
                                duration: m.duration.toFixed(2) + 'ms',
                                startTime: m.startTime.toFixed(2)
                            })) : [],
                        logEntries: window.__1c_log ? window.__1c_log.filter(e => e.component === 'cfo-dashboard' && e.level === 'perf').slice(-5) : []
                    }
                };
                
                return JSON.stringify(snapshot, null, 2);
            } catch (error) {
                console.error('Error getting KPI snapshot:', error);
                return JSON.stringify({ error: error.message });
            }
        },
        updateDashboard: function(jsonData) {
            try {
                // B2: Performance measurement - updateDashboard
                if (window.performance && window.performance.mark) {
                    window.performance.mark('updateDashboard-start');
                }
                
                let data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                
                // D2: Проверка версии схемы и миграция
                const versionCheck = checkSchemaVersion(data);
                if (!versionCheck.compatible) {
                    showSchemaVersionWarning(versionCheck.message);
                    return { success: false, message: versionCheck.message };
                }
                
                if (versionCheck.requiresMigration) {
                    console.log('Schema migration required:', versionCheck.message);
                    data = migrateData(data);
                    console.log('Migration completed successfully');
                }
                
                // Валидация данных
                const validation = validateData(data, true);
                
                if (!validation.valid) {
                    console.warn('Data validation failed, but continuing with graceful degradation');
                    // Продолжаем работу с предупреждениями, но не с критическими ошибками
                }
                
                renderDashboard(data);
                
                // Performance measurement end
                if (window.performance && window.performance.mark && window.performance.measure) {
                    window.performance.mark('updateDashboard-end');
                    window.performance.measure('updateDashboard', 'updateDashboard-start', 'updateDashboard-end');
                    
                    var measures = window.performance.getEntriesByName('updateDashboard');
                    if (measures.length > 0) {
                        var duration = measures[measures.length - 1].duration;
                        if (window.CFODashboard && window.CFODashboard.log) {
                            window.CFODashboard.log('perf', 'updateDashboard', { 
                                duration: duration.toFixed(2) + 'ms',
                                targetMs: '≤50ms',
                                passed: duration <= 50
                            });
                        }
                    }
                }
                
                return { 
                    success: true, 
                    message: 'Dashboard updated successfully',
                    validation: validation
                };
            } catch (error) {
                console.error('Error updating dashboard:', error);
                if (window.errorBoundary) {
                    window.errorBoundary.reportError(error, 'updateDashboard');
                }
                return { success: false, message: error.message };
            }
        },
        
        getDashboardState: function() {
            return {
                lastUpdate: dashboardData?.meta?.period || null,
                chartsCount: Object.keys(charts).length,
                alertsCount: dashboardData?.alerts?.length || 0
            };
        },
        
        /**
         * E2: Batch export functionality with manifest
         * @method createBatchExportManifest
         * @description Create a comprehensive export manifest for batch processing
         * @returns {Object} Export manifest with metadata and page information
         */
        createBatchExportManifest: function() {
            try {
                return createBatchExportManifest();
            } catch (error) {
                console.error('Error creating batch export manifest:', error);
                return { 
                    success: false, 
                    message: error.message,
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    exports: []
                };
            }
        },
        
        /**
         * E2: Execute batch export with manifest
         * @method executeBatchExport
         * @description Execute sequential export of all dashboard pages with manifest generation
         * @returns {Object} Export manifest with execution results
         */
        executeBatchExport: function() {
            try {
                return executeBatchExport();
            } catch (error) {
                console.error('Error executing batch export:', error);
                return Promise.resolve({ 
                    success: false, 
                    message: error.message,
                    summary: {
                        totalExports: 0,
                        successful: 0,
                        failed: 1,
                        error: error.message
                    }
                });
            }
        },
        
        /**
         * E2: Export current page with Promise interface
         * @method exportCurrentPagePromise
         * @description Export current page as PNG with Promise-based interface for batch processing
         * @returns {Promise<Object>} Promise resolving to export result
         */
        exportCurrentPagePromise: function() {
            try {
                return exportCurrentPagePromise();
            } catch (error) {
                console.error('Error exporting current page promise:', error);
                return Promise.resolve({
                    success: false,
                    message: error.message,
                    pageId: currentPage
                });
            }
        },
        
        /**
         * F1: Smoke test suite
         * @method runSmokeTests
         * @description Execute comprehensive smoke test suite
         * @returns {Object} Test results with summary and detailed results
         */
        runSmokeTests: function() {
            try {
                return smokeTests.runAll();
            } catch (error) {
                console.error('Error running smoke tests:', error);
                return {
                    summary: {
                        totalTests: 0,
                        passedTests: 0,
                        failedTests: 1,
                        successRate: '0%',
                        error: error.message
                    },
                    suites: {}
                };
            }
        },
        
        /**
         * F1: Generate smoke test report
         * @method getSmokeTestReport
         * @description Generate human-readable smoke test report
         * @returns {String} Formatted test report
         */
        getSmokeTestReport: function() {
            try {
                return smokeTests.generateReport();
            } catch (error) {
                console.error('Error generating smoke test report:', error);
                return 'Error generating report: ' + error.message;
            }
        },
        
        /**
         * F1: Regression test utilities
         * @method capturePerformanceBaseline
         * @description Capture current performance metrics as baseline for regression testing
         * @returns {Object} Baseline performance metrics
         */
        capturePerformanceBaseline: function() {
            try {
                return regressionTests.captureBaseline();
            } catch (error) {
                console.error('Error capturing performance baseline:', error);
                return { error: error.message };
            }
        },
        
        /**
         * F1: Compare performance to baseline
         * @method comparePerformanceToBaseline
         * @description Compare current performance metrics against stored baseline
         * @returns {Object} Performance comparison with regressions and improvements
         */
        comparePerformanceToBaseline: function() {
            try {
                return regressionTests.compareToBaseline();
            } catch (error) {
                console.error('Error comparing performance to baseline:', error);
                return { error: error.message };
            }
        },
        
        /**
         * F2: Visual optimization controls
         * @method optimizeVisualClarity
         * @description Apply all visual optimizations for better sharpness and contrast
         * @returns {Object} Result object with optimization status
         */
        optimizeVisualClarity: function() {
            try {
                const success = visualOptimization.optimizeAll();
                return { 
                    success: success, 
                    message: success ? 'Visual optimizations applied successfully' : 'Visual optimization failed' 
                };
            } catch (error) {
                console.error('Error optimizing visual clarity:', error);
                return { success: false, message: error.message };
            }
        },
        
        /**
         * F2: Enhance chart visibility
         * @method enhanceChartVisibility  
         * @description Apply high-DPI and sharpness optimizations to all charts
         * @returns {Object} Result object with enhancement status
         */
        enhanceChartVisibility: function() {
            try {
                visualOptimization.enhanceChartVisibility();
                return { success: true, message: 'Chart visibility enhanced successfully' };
            } catch (error) {
                console.error('Error enhancing chart visibility:', error);
                return { success: false, message: error.message };
            }
        },
        
        /**
         * F2: Optimize font rendering
         * @method optimizeFontRendering
         * @description Apply font smoothing and clarity optimizations
         * @returns {Object} Result object with optimization status  
         */
        optimizeFontRendering: function() {
            try {
                visualOptimization.optimizeFontRendering();
                return { success: true, message: 'Font rendering optimized successfully' };
            } catch (error) {
                console.error('Error optimizing font rendering:', error);
                return { success: false, message: error.message };
            }
        }
    };

    // Тестовые данные
    const sampleData = {
        "meta": {
            "period": "2024-11-30",
            "currency": "RUB",
            "company": "ООО Прогресс",
            "reportType": "monthly"
        },
        "kpi": {
            "revenue": {
                "current": 125600000,
                "momChange": 8.5,
                "yoyChange": 23.2
            },
            "ebitda": 28900000,
            "ocf": 31200000,
            "cashEnd": 45600000,
            "cashRunwayMonths": 4.2,
            "margins": {
                "gross": 42.3,
                "ebitda": 23.1,
                "net": 18.7
            }
        },
        "timeSeries": {
            "revenue": {
                "fact": [98.5, 105.2, 112.3, 108.9, 115.6, 120.3, 125.6],
                "plan": [100, 108, 116, 112, 118, 124, 130],
                "prevYear": [89.2, 92.1, 95.8, 99.2, 102.5, 108.9, 115.2],
                "forecast": [131, 136.5, 142],
                "dates": ["Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя"]
            },
            "margins": {
                "gross": [41.2, 41.8, 42.1, 41.6, 42.0, 42.2, 42.3],
                "ebitda": [22.1, 22.8, 23.2, 22.5, 23.0, 23.3, 23.1],
                "net": [17.8, 18.2, 18.6, 18.1, 18.4, 18.9, 18.7],
                "dates": ["Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя"]
            },
            "cashFlow": {
                "opening": 38200000,
                "ocf": [31200000],
                "icf": [-15600000],
                "fcf": [15600000],
                "closing": 45600000,
                "labels": ["Opening", "OCF", "ICF", "FCF", "Closing"]
            }
        },
        "structures": {
            "byBranch": [
                {"name": "Розница", "revenue": 75360000, "profit": 18200000, "margin": 24.1, "share": 60.0},
                {"name": "Опт", "revenue": 37680000, "profit": 8900000, "margin": 23.6, "share": 30.0},
                {"name": "Онлайн", "revenue": 12560000, "profit": 1800000, "margin": 14.3, "share": 10.0}
            ]
        },
        "debtors": [
            {"name": "ООО Альфа", "amount": 5600000, "daysOverdue": 45, "bucket": "31-60", "expectedDate": "2024-12-15", "creditLimit": 8000000, "manager": "Иванов И.И."},
            {"name": "ИП Петров", "amount": 3200000, "daysOverdue": 15, "bucket": "0-30", "expectedDate": "2024-12-05", "creditLimit": 5000000, "manager": "Сидоров С.С."},
            {"name": "ООО Бета", "amount": 2800000, "daysOverdue": 95, "bucket": "90+", "expectedDate": "2025-01-30", "creditLimit": 3000000, "manager": "Козлов К.К."},
            {"name": "ООО Гамма", "amount": 1900000, "daysOverdue": 0, "bucket": "0-30", "expectedDate": "2024-12-10", "creditLimit": 4000000, "manager": "Волков В.В."},
            {"name": "ЗАО Дельта", "amount": 950000, "daysOverdue": 67, "bucket": "61-90", "expectedDate": "2024-12-20", "creditLimit": 1200000, "manager": "Петров П.П."}
        ],
        "coefficients": {
            "current": 2.1,
            "quick": 1.8,
            "debtEbitda": 2.3,
            "interestCoverage": 12.5,
            "autonomy": 0.68,
            "dso": 47,
            "dpo": 35,
            "dii": 28,
            "ccc": 40,
            "targets": {
                "current": [1.5, 2.5],
                "quick": [1.0, 2.0],
                "debtEbitda": [0.0, 3.0],
                "ccc": [30, 50]
            },
            "sparklines": {
                "current": [1.9, 2.0, 2.1, 2.0, 2.1],
                "quick": [1.7, 1.8, 1.9, 1.8, 1.8],
                "debtEbitda": [2.5, 2.4, 2.3, 2.3, 2.3],
                "interestCoverage": [11.2, 11.8, 12.1, 12.3, 12.5],
                "autonomy": [0.65, 0.66, 0.67, 0.68, 0.68],
                "dso": [45, 46, 48, 47, 47],
                "dpo": [33, 34, 35, 35, 35],
                "dii": [30, 29, 28, 28, 28],
                "ccc": [42, 41, 39, 40, 40]
            }
        },
        "planFactDrivers": [
            {"driver": "Выручка", "fact": 125600000, "plan": 130000000, "variance": -4400000, "variancePercent": -3.4},
            {"driver": "COGS", "fact": 72500000, "plan": 75400000, "variance": 2900000, "variancePercent": 3.8},
            {"driver": "EBITDA", "fact": 28900000, "plan": 30600000, "variance": -1700000, "variancePercent": -5.6}
        ],
        "cashAccounts": [
            {"bank": "Сбербанк", "available": 28600000, "blocked": 1200000, "concentration": 65.2},
            {"bank": "ВТБ", "available": 12800000, "blocked": 0, "concentration": 28.1},
            {"bank": "Альфа-Банк", "available": 3200000, "blocked": 0, "concentration": 7.0}
        ],
        "alerts": [
            {"type": "overdue", "severity": "medium", "message": "Просрочка по ООО Бета превышает 90 дней"},
            {"type": "concentration", "severity": "high", "message": "Концентрация в Сбербанке превышает 60%"},
            {"type": "cash_shortage", "severity": "medium", "message": "Cash Runway менее 6 месяцев"}
        ]
    };

    // Enhanced переключатель Абсолют/100% с localStorage
    function initializeShareModeToggle() {
        const savedMode = localStorage.getItem('dash.mode.share') || 'absolute';
        
        // Установка начального состояния
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === savedMode);
        });
        
        // Обработчики событий
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.addEventListener('click', function() {
                const mode = this.dataset.mode;
                applyShareMode(mode); // C1: Используем единую функцию
            });
        });
    }
    
    // C1: Единая функция для применения режима "Абсолют/100%"
    function applyShareMode(mode) {
        const startTime = performance.now();
        
        // Сохраняем режим в localStorage
        localStorage.setItem('dash.mode.share', mode);
        
        // Обновляем UI кнопок
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });
        
        // Обновляем графики без пересоздания
        if (dashboardData && charts['revenue-branches-chart']) {
            updateBranchesChart(dashboardData.structures.byBranch, mode);
        }
        
        // Performance logging
        const duration = performance.now() - startTime;
        if (window.CFODashboard && window.CFODashboard.log) {
            window.CFODashboard.log('perf', 'applyShareMode', { 
                mode: mode,
                duration: duration.toFixed(2) + 'ms',
                targetMs: '≤25ms',
                passed: duration <= 25
            });
        }
        
        return true;
    }
    
    // Быстрое обновление данных графика без пересоздания
    function updateBranchesChart(data, mode) {
        const chart = charts['revenue-branches-chart'];
        if (!chart) return;
        
        const startTime = performance.now();
        
        // Пересортировка данных
        const sortedData = [...data].sort((a, b) => b.revenue - a.revenue);
        
        // Обновляем данные
        chart.data.labels = sortedData.map(d => d.name);
        chart.data.datasets[0].data = mode === 'absolute' ? 
            sortedData.map(d => d.revenue) : 
            sortedData.map(d => d.share);
        
        // Обновляем ось Y
        chart.options.scales.x.ticks.callback = function(value) {
            return mode === 'absolute' ? 
                formatters.millions(value) : 
                formatters.percent(value);
        };
        
        // Быстрое обновление
        chart.update('none');
        
        const endTime = performance.now();
        console.log(`Branches chart update: ${(endTime - startTime).toFixed(1)}ms`);
    }
    
    // Благородная палитра категорий
    const CATEGORY_COLORS = [
        '#2c3e50', // Глубокий сине-серый
        '#8e44ad', // Аметистовый фиолетовый
        '#2980b9', // Сапфировый синий  
        '#16a085', // Изумрудный бирюзовый
        '#f39c12', // Золотисто-янтарный
        '#c0392b', // Рубиновый красный
        '#7f8c8d', // Платиновый серый
        '#d35400'  // Медный оранжевый
    ];
    
    // Обновленная функция createHorizontalBarChart с поддержкой палитры
    const originalCreateHorizontalBarChart = createHorizontalBarChart;
    createHorizontalBarChart = function(canvasId, data, mode = 'absolute') {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Загружаем сохраненный режим
        const savedMode = localStorage.getItem('dash.mode.share') || mode;
        
        // Сортировка по убыванию
        const sortedData = [...data].sort((a, b) => b.revenue - a.revenue);
        
        const chartData = {
            labels: sortedData.map(d => d.name),
            datasets: [{
                label: 'Выручка',
                data: savedMode === 'absolute' ? 
                    sortedData.map(d => d.revenue) : 
                    sortedData.map(d => d.share),
                backgroundColor: sortedData.map((_, index) => CATEGORY_COLORS[index % CATEGORY_COLORS.length]),
                borderColor: sortedData.map((_, index) => CATEGORY_COLORS[index % CATEGORY_COLORS.length]),
                borderWidth: 1
            }]
        };

        const chart = new Chart(ctx, {
            type: 'bar',
            data: chartData,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                animation: false, // Отключаем анимации для быстрого переключения
                parsing: false,
                normalized: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const item = sortedData[context.dataIndex];
                                return [
                                    `Выручка: ${formatters.currency(item.revenue)}`,
                                    `Прибыль: ${formatters.currency(item.profit)}`,
                                    `Маржа: ${formatters.percent(item.margin)}`,
                                    `Доля: ${formatters.percent(item.share)}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                return savedMode === 'absolute' ? 
                                    formatters.millions(value) : 
                                    formatters.percent(value);
                            }
                        }
                    }
                },
                onResize: function(chart) {
                    ensureHiDPI(chart.canvas);
                }
            }
        });
        
        // Initialize HiDPI on creation
        ensureHiDPI(ctx.canvas);
        
        return chart;
    };

    
    // E2: Batch-export manifest functionality
    function createBatchExportManifest() {
        const startTime = performance.now();
        
        // Create export manifest with metadata
        const manifest = {
            version: "1.0",
            timestamp: new Date().toISOString(),
            dashboard: {
                name: "CFO Dashboard",
                version: "3.0.0",
                company: dashboardData?.meta?.company || 'ООО «Прогресс»',
                period: dashboardData?.meta?.period || new Date().toISOString().split('T')[0],
                currency: dashboardData?.meta?.currency || 'RUB'
            },
            exports: [],
            formats: {
                supported: ['PNG', 'PDF', 'JSON'],
                default: 'PNG'
            },
            settings: {
                resolution: 'high',
                colorMode: 'color',
                pageSize: 'A4',
                orientation: 'landscape'
            },
            metadata: {
                totalPages: Object.keys(PAGE_DEFINITIONS).length,
                exportedAt: new Date().toISOString(),
                userAgent: navigator.userAgent,
                viewportSize: {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            }
        };
        
        // Add each page to the manifest
        Object.entries(PAGE_DEFINITIONS).forEach(([pageId, pageDef]) => {
            const pageExport = {
                pageId: pageId,
                pageName: pageDef.name,
                filename: `cfo_dashboard_${pageId}_${manifest.dashboard.period}.png`,
                description: `CFO Dashboard - ${pageDef.name}`,
                order: parseInt(pageId),
                status: 'pending',
                metadata: {
                    hasCharts: document.querySelectorAll(`#page-${pageId} canvas`).length > 0,
                    hasKPIs: document.querySelectorAll(`#page-${pageId} .kpi-card`).length > 0,
                    hasAlerts: document.querySelectorAll(`#page-${pageId} .alert-card`).length > 0,
                    estimatedSize: '~500KB'
                }
            };
            manifest.exports.push(pageExport);
        });
        
        // Performance measurement
        const duration = performance.now() - startTime;
        if (window.CFODashboard && window.CFODashboard.log) {
            window.CFODashboard.log('perf', 'createBatchExportManifest', { 
                pageCount: manifest.exports.length,
                duration: duration.toFixed(2) + 'ms'
            });
        }
        
        return manifest;
    }
    
    
    // Enhanced export function that returns a Promise for batch processing
    function exportCurrentPagePromise() {
        return new Promise((resolve, reject) => {
            try {
                if (window.external1C && typeof window.external1C.exportCurrentPagePNG === 'function') {
                    // 1C integration mode
                    window.external1C.exportCurrentPagePNG()
                        .then(result => resolve(result))
                        .catch(error => reject(error));
                } else {
                    // Browser mode - simulate export
                    console.log(`Simulating export of page ${currentPage}`);
                    
                    // Create mock successful result
                    const result = {
                        success: true,
                        pageName: PAGE_DEFINITIONS[currentPage]?.name || 'Неизвестная страница',
                        pageId: currentPage,
                        width: 1920,
                        height: 1080,
                        size: Math.floor(Math.random() * 500) + 200 + 'KB',
                        dataUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                        exportedAt: new Date().toISOString()
                    };
                    
                    // Simulate async operation
                    setTimeout(() => resolve(result), 200);
                }
            } catch (error) {
                reject(error);
            }
        });
    }
    
    // F1: Smoke test suite and regression tests
    const smokeTests = {
        version: '1.0.0',
        lastRun: null,
        results: {},
        
        // Smoke test definitions
        tests: {
            'core-initialization': {
                name: 'Core Initialization',
                description: 'Check if core dashboard components initialize correctly',
                run: function() {
                    const results = [];
                    
                    // Test 1: Dashboard data loaded
                    if (typeof dashboardData === 'undefined' || !dashboardData) {
                        results.push({ test: 'dashboardData', passed: false, message: 'Dashboard data not loaded' });
                    } else {
                        results.push({ test: 'dashboardData', passed: true, message: 'Dashboard data loaded successfully' });
                    }
                    
                    // Test 2: Charts object exists
                    if (typeof charts === 'undefined' || !charts) {
                        results.push({ test: 'charts', passed: false, message: 'Charts object not initialized' });
                    } else {
                        results.push({ test: 'charts', passed: true, message: `Charts object initialized (${Object.keys(charts).length} charts)` });
                    }
                    
                    // Test 3: External1C API available
                    if (typeof window.external1C === 'undefined') {
                        results.push({ test: 'external1C', passed: false, message: 'External1C API not available' });
                    } else {
                        results.push({ test: 'external1C', passed: true, message: 'External1C API available' });
                    }
                    
                    // Test 4: Page definitions loaded
                    if (typeof PAGE_DEFINITIONS === 'undefined' || Object.keys(PAGE_DEFINITIONS).length === 0) {
                        results.push({ test: 'PAGE_DEFINITIONS', passed: false, message: 'Page definitions not loaded' });
                    } else {
                        results.push({ test: 'PAGE_DEFINITIONS', passed: true, message: `${Object.keys(PAGE_DEFINITIONS).length} pages defined` });
                    }
                    
                    return results;
                }
            },
            
            'ui-rendering': {
                name: 'UI Rendering',
                description: 'Verify essential UI elements are rendered',
                run: function() {
                    const results = [];
                    
                    // Test 1: Navigation exists
                    const nav = document.querySelector('.page-navigation');
                    results.push({ 
                        test: 'navigation', 
                        passed: !!nav, 
                        message: nav ? 'Navigation rendered' : 'Navigation not found' 
                    });
                    
                    // Test 2: KPI cards exist
                    const kpiCards = document.querySelectorAll('.kpi-card');
                    results.push({ 
                        test: 'kpiCards', 
                        passed: kpiCards.length > 0, 
                        message: `${kpiCards.length} KPI cards found` 
                    });
                    
                    // Test 3: Charts containers exist
                    const chartContainers = document.querySelectorAll('.chart-container');
                    results.push({ 
                        test: 'chartContainers', 
                        passed: chartContainers.length > 0, 
                        message: `${chartContainers.length} chart containers found` 
                    });
                    
                    // Test 4: Error boundary banner (should be hidden initially)
                    const errorBanner = document.querySelector('#error-banner');
                    results.push({ 
                        test: 'errorBanner', 
                        passed: !!errorBanner, 
                        message: errorBanner ? 'Error boundary banner present' : 'Error boundary banner missing' 
                    });
                    
                    return results;
                }
            },
            
            'performance': {
                name: 'Performance Checks',
                description: 'Basic performance and timing checks',
                run: function() {
                    const results = [];
                    
                    // Test 1: Performance API available
                    const perfAvailable = typeof window.performance !== 'undefined' && window.performance.now;
                    results.push({ 
                        test: 'performanceAPI', 
                        passed: perfAvailable, 
                        message: perfAvailable ? 'Performance API available' : 'Performance API not available' 
                    });
                    
                    // Test 2: Check recent performance measures
                    if (perfAvailable && window.performance.getEntriesByType) {
                        const measures = window.performance.getEntriesByType('measure').filter(m => 
                            m.name.includes('Dashboard') || m.name.includes('update') || m.name.includes('filter')
                        );
                        results.push({ 
                            test: 'performanceMeasures', 
                            passed: true, 
                            message: `${measures.length} performance measures recorded` 
                        });
                        
                        // Check if any measures exceed thresholds
                        const slowMeasures = measures.filter(m => m.duration > 100);
                        if (slowMeasures.length > 0) {
                            results.push({ 
                                test: 'slowOperations', 
                                passed: false, 
                                message: `${slowMeasures.length} operations took >100ms` 
                            });
                        } else {
                            results.push({ 
                                test: 'slowOperations', 
                                passed: true, 
                                message: 'No slow operations detected' 
                            });
                        }
                    }
                    
                    return results;
                }
            },
            
            'data-integrity': {
                name: 'Data Integrity',
                description: 'Validate data structure and content',
                run: function() {
                    const results = [];
                    
                    if (!dashboardData) {
                        results.push({ test: 'noData', passed: false, message: 'No dashboard data to validate' });
                        return results;
                    }
                    
                    // Test 1: Meta information
                    const hasMeta = dashboardData.meta && dashboardData.meta.company && dashboardData.meta.period;
                    results.push({ 
                        test: 'metaData', 
                        passed: hasMeta, 
                        message: hasMeta ? 'Meta information complete' : 'Meta information missing' 
                    });
                    
                    // Test 2: KPI data
                    const hasKPI = dashboardData.kpi && typeof dashboardData.kpi.revenue !== 'undefined';
                    results.push({ 
                        test: 'kpiData', 
                        passed: hasKPI, 
                        message: hasKPI ? 'KPI data present' : 'KPI data missing' 
                    });
                    
                    // Test 3: Time series data
                    const hasTimeSeries = dashboardData.timeSeries && dashboardData.timeSeries.revenue;
                    results.push({ 
                        test: 'timeSeriesData', 
                        passed: hasTimeSeries, 
                        message: hasTimeSeries ? 'Time series data present' : 'Time series data missing' 
                    });
                    
                    // Test 4: Data validation
                    try {
                        const validation = validateData(dashboardData, false);
                        results.push({ 
                            test: 'dataValidation', 
                            passed: validation.valid, 
                            message: validation.valid ? 'Data validation passed' : `Data validation failed: ${validation.errors.length} errors` 
                        });
                    } catch (error) {
                        results.push({ 
                            test: 'dataValidation', 
                            passed: false, 
                            message: 'Data validation threw error: ' + error.message 
                        });
                    }
                    
                    return results;
                }
            },
            
            'functionality': {
                name: 'Basic Functionality',
                description: 'Test core dashboard functions',
                run: function() {
                    const results = [];
                    
                    // Test 1: Page switching
                    const originalPage = currentPage;
                    try {
                        const testPageId = Object.keys(PAGE_DEFINITIONS)[1] || 0; // Try second page
                        switchPage(testPageId);
                        const switched = currentPage == testPageId;
                        switchPage(originalPage); // Restore
                        
                        results.push({ 
                            test: 'pageSwitching', 
                            passed: switched, 
                            message: switched ? 'Page switching works' : 'Page switching failed' 
                        });
                    } catch (error) {
                        results.push({ 
                            test: 'pageSwitching', 
                            passed: false, 
                            message: 'Page switching error: ' + error.message 
                        });
                    }
                    
                    // Test 2: Filter application
                    try {
                        const oldFilters = {...currentFilters};
                        applyFilters();
                        results.push({ 
                            test: 'filterApplication', 
                            passed: true, 
                            message: 'Filter application completed without errors' 
                        });
                    } catch (error) {
                        results.push({ 
                            test: 'filterApplication', 
                            passed: false, 
                            message: 'Filter application error: ' + error.message 
                        });
                    }
                    
                    // Test 3: Chart rendering
                    const chartsWithData = Object.values(charts).filter(chart => chart && chart.data);
                    results.push({ 
                        test: 'chartRendering', 
                        passed: chartsWithData.length > 0, 
                        message: `${chartsWithData.length} charts with data rendered` 
                    });
                    
                    return results;
                }
            },
            
            'error-handling': {
                name: 'Error Handling',
                description: 'Test error boundary and error handling',
                run: function() {
                    const results = [];
                    
                    // Test 1: Error boundary exists
                    const errorBoundaryExists = typeof window.errorBoundary !== 'undefined' && window.errorBoundary.reportError;
                    results.push({ 
                        test: 'errorBoundaryExists', 
                        passed: errorBoundaryExists, 
                        message: errorBoundaryExists ? 'Error boundary available' : 'Error boundary not available' 
                    });
                    
                    // Test 2: Mini-linter self-check
                    if (typeof window.__dbg !== 'undefined' && window.__dbg.selfCheck) {
                        try {
                            const selfCheck = window.__dbg.selfCheck();
                            results.push({ 
                                test: 'miniLinter', 
                                passed: selfCheck.passed, 
                                message: `Mini-linter: ${selfCheck.summary}` 
                            });
                        } catch (error) {
                            results.push({ 
                                test: 'miniLinter', 
                                passed: false, 
                                message: 'Mini-linter failed: ' + error.message 
                            });
                        }
                    }
                    
                    return results;
                }
            }
        },
        
        // Run all smoke tests
        runAll: function() {
            const startTime = performance.now();
            const allResults = {};
            let totalTests = 0;
            let passedTests = 0;
            
            console.log('🧪 Running CFO Dashboard Smoke Tests...');
            
            Object.entries(this.tests).forEach(([testId, testSuite]) => {
                console.log(`Running: ${testSuite.name}`);
                
                try {
                    const suiteResults = testSuite.run();
                    allResults[testId] = {
                        name: testSuite.name,
                        description: testSuite.description,
                        results: suiteResults,
                        passed: suiteResults.every(r => r.passed),
                        timestamp: new Date().toISOString()
                    };
                    
                    totalTests += suiteResults.length;
                    passedTests += suiteResults.filter(r => r.passed).length;
                    
                } catch (error) {
                    allResults[testId] = {
                        name: testSuite.name,
                        description: testSuite.description,
                        error: error.message,
                        passed: false,
                        timestamp: new Date().toISOString()
                    };
                    totalTests += 1;
                }
            });
            
            const duration = performance.now() - startTime;
            const summary = {
                totalTests,
                passedTests,
                failedTests: totalTests - passedTests,
                successRate: ((passedTests / totalTests) * 100).toFixed(1) + '%',
                duration: duration.toFixed(2) + 'ms',
                timestamp: new Date().toISOString()
            };
            
            this.lastRun = new Date().toISOString();
            this.results = { summary, suites: allResults };
            
            // Log results
            if (window.CFODashboard && window.CFODashboard.log) {
                window.CFODashboard.log('info', 'smokeTestsCompleted', summary);
            }
            
            console.log(`🧪 Smoke Tests Complete: ${summary.successRate} (${passedTests}/${totalTests})`);
            
            return this.results;
        },
        
        // Run specific test suite
        run: function(testId) {
            if (!this.tests[testId]) {
                throw new Error(`Test suite '${testId}' not found`);
            }
            
            const testSuite = this.tests[testId];
            console.log(`Running: ${testSuite.name}`);
            
            try {
                const results = testSuite.run();
                const passed = results.every(r => r.passed);
                
                return {
                    testId,
                    name: testSuite.name,
                    results,
                    passed,
                    timestamp: new Date().toISOString()
                };
            } catch (error) {
                return {
                    testId,
                    name: testSuite.name,
                    error: error.message,
                    passed: false,
                    timestamp: new Date().toISOString()
                };
            }
        },
        
        // Generate test report
        generateReport: function() {
            if (!this.results.summary) {
                return 'No test results available. Run smokeTests.runAll() first.';
            }
            
            const { summary, suites } = this.results;
            let report = `CFO Dashboard Smoke Test Report\n`;
            report += `Generated: ${summary.timestamp}\n`;
            report += `Duration: ${summary.duration}\n`;
            report += `Success Rate: ${summary.successRate} (${summary.passedTests}/${summary.totalTests})\n\n`;
            
            Object.entries(suites).forEach(([testId, suite]) => {
                report += `${suite.name}\n`;
                report += `${'='.repeat(suite.name.length)}\n`;
                report += `${suite.description}\n`;
                report += `Status: ${suite.passed ? '✅ PASSED' : '❌ FAILED'}\n\n`;
                
                if (suite.results) {
                    suite.results.forEach(result => {
                        const status = result.passed ? '✅' : '❌';
                        report += `  ${status} ${result.test}: ${result.message}\n`;
                    });
                } else if (suite.error) {
                    report += `  ❌ Error: ${suite.error}\n`;
                }
                
                report += '\n';
            });
            
            return report;
        }
    };
    
    // Regression test utilities
    const regressionTests = {
        // Capture baseline performance metrics
        captureBaseline: function() {
            const baseline = {
                timestamp: new Date().toISOString(),
                performance: {
                    updateDashboard: this.measureOperation('updateDashboard', () => {
                        if (dashboardData) renderDashboard(dashboardData);
                    }),
                    switchPage: this.measureOperation('switchPage', () => {
                        const currentPage = getCurrentPage();
                        switchPage(currentPage === 0 ? 1 : 0);
                        switchPage(currentPage);
                    }),
                    applyFilters: this.measureOperation('applyFilters', () => {
                        applyFilters();
                    })
                },
                memory: this.getMemoryUsage(),
                chartCount: Object.keys(charts).length,
                domElements: document.querySelectorAll('*').length
            };
            
            localStorage.setItem('dash.regression.baseline', JSON.stringify(baseline));
            return baseline;
        },
        
        // Compare current performance against baseline
        compareToBaseline: function() {
            const baselineStr = localStorage.getItem('dash.regression.baseline');
            if (!baselineStr) {
                return { error: 'No baseline captured. Run regressionTests.captureBaseline() first.' };
            }
            
            const baseline = JSON.parse(baselineStr);
            const current = this.captureBaseline();
            
            const comparison = {
                timestamp: current.timestamp,
                baselineDate: baseline.timestamp,
                performance: {},
                regressions: [],
                improvements: []
            };
            
            // Compare performance metrics
            Object.entries(baseline.performance).forEach(([op, baselineTime]) => {
                const currentTime = current.performance[op];
                const change = ((currentTime - baselineTime) / baselineTime) * 100;
                
                comparison.performance[op] = {
                    baseline: baselineTime,
                    current: currentTime,
                    change: change.toFixed(1) + '%',
                    regression: change > 20 // Consider >20% slower as regression
                };
                
                if (change > 20) {
                    comparison.regressions.push({
                        operation: op,
                        change: change.toFixed(1) + '%',
                        baseline: baselineTime,
                        current: currentTime
                    });
                } else if (change < -10) {
                    comparison.improvements.push({
                        operation: op,
                        improvement: Math.abs(change).toFixed(1) + '%',
                        baseline: baselineTime,
                        current: currentTime
                    });
                }
            });
            
            return comparison;
        },
        
        measureOperation: function(name, operation) {
            const startTime = performance.now();
            try {
                operation();
            } catch (error) {
                console.warn(`Regression test operation '${name}' failed:`, error);
            }
            return performance.now() - startTime;
        },
        
        getMemoryUsage: function() {
            if (performance.memory) {
                return {
                    used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                    total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
                };
            }
            return null;
        }
    };
    
    // Export test utilities to global scope
    window.smokeTests = smokeTests;
    window.regressionTests = regressionTests;
    
    // F2: Sharpness and contrast optimization utilities
    const visualOptimization = {
        // Enhance chart sharpness and contrast
        enhanceChartVisibility: function() {
            Object.values(charts).forEach(chart => {
                if (chart && chart.canvas) {
                    const canvas = chart.canvas;
                    const ctx = canvas.getContext('2d');
                    
                    // Enable high-DPI rendering
                    const devicePixelRatio = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();
                    
                    canvas.width = rect.width * devicePixelRatio;
                    canvas.height = rect.height * devicePixelRatio;
                    
                    canvas.style.width = rect.width + 'px';
                    canvas.style.height = rect.height + 'px';
                    
                    ctx.scale(devicePixelRatio, devicePixelRatio);
                    
                    // Enhance rendering quality
                    ctx.imageSmoothingEnabled = false;
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'center';
                    
                    // Force chart redraw with enhanced settings
                    if (chart.update && typeof chart.update === 'function') {
                        chart.update('none');
                    }
                }
            });
        },
        
        // Optimize font rendering for clarity
        optimizeFontRendering: function() {
            const style = document.createElement('style');
            style.textContent = `
                @font-face {
                    font-family: 'System';
                    font-style: normal;
                    font-weight: 300;
                    src: local('.AppleSystemUIFont'), local('-apple-system'), local('BlinkMacSystemFont'), local('Segoe UI'), local('Roboto'), local('Oxygen'), local('Ubuntu'), local('Cantarell'), local('Droid Sans'), local('Helvetica Neue'), sans-serif;
                }
                
                body, input, textarea, select, button {
                    font-family: 'System', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                    font-variant-ligatures: none;
                    -webkit-font-feature-settings: "liga" off;
                    font-feature-settings: "liga" off;
                }
                
                .kpi-value, .section-title {
                    font-variant-numeric: tabular-nums;
                    -webkit-font-feature-settings: "tnum" on;
                    font-feature-settings: "tnum" on;
                }
            `;
            
            // Remove existing optimization if it exists
            const existingOptimization = document.getElementById('font-optimization');
            if (existingOptimization) {
                existingOptimization.remove();
            }
            
            style.id = 'font-optimization';
            document.head.appendChild(style);
        },
        
        // Enhance color contrast for accessibility
        enhanceColorContrast: function() {
            // Apply high-contrast mode classes if needed
            const contrastRatio = this.calculateContrastRatio('#ffffff', '#000000');
            
            if (contrastRatio < 4.5) {
                document.body.classList.add('high-contrast-mode');
            }
            
            // Enhance sparkline visibility
            document.querySelectorAll('.sparkline').forEach(canvas => {
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.lineWidth = Math.max(1.5, ctx.lineWidth || 1);
                }
            });
        },
        
        // Calculate color contrast ratio (WCAG standards)
        calculateContrastRatio: function(color1, color2) {
            const getLuminance = (color) => {
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16) / 255;
                const g = parseInt(hex.substr(2, 2), 16) / 255;
                const b = parseInt(hex.substr(4, 2), 16) / 255;
                
                const sRGB = [r, g, b].map(c => {
                    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                });
                
                return 0.2126 * sRGB[0] + 0.7152 * sRGB[1] + 0.0722 * sRGB[2];
            };
            
            const lum1 = getLuminance(color1);
            const lum2 = getLuminance(color2);
            const brightest = Math.max(lum1, lum2);
            const darkest = Math.min(lum1, lum2);
            
            return (brightest + 0.05) / (darkest + 0.05);
        },
        
        // Apply sharpness filters to enhance visual clarity
        applySharpnessFilter: function() {
            const style = document.createElement('style');
            style.textContent = `
                .kpi-card, .chart-container {
                    filter: contrast(1.05) saturate(1.02);
                    -webkit-filter: contrast(1.05) saturate(1.02);
                }
                
                canvas {
                    filter: contrast(1.08) brightness(1.02);
                    -webkit-filter: contrast(1.08) brightness(1.02);
                }
                
                .kpi-value {
                    filter: contrast(1.1);
                    -webkit-filter: contrast(1.1);
                }
                
                @media (prefers-contrast: high) {
                    * {
                        filter: contrast(1.2) !important;
                        -webkit-filter: contrast(1.2) !important;
                    }
                }
                
                @media (prefers-reduced-motion: no-preference) {
                    .kpi-card, .chart-container {
                        transition: filter 0.2s ease;
                    }
                }
            `;
            
            // Remove existing filter if it exists
            const existingFilter = document.getElementById('sharpness-filter');
            if (existingFilter) {
                existingFilter.remove();
            }
            
            style.id = 'sharpness-filter';
            document.head.appendChild(style);
        },
        
        // Optimize for different display types
        detectAndOptimizeDisplay: function() {
            const isRetina = window.devicePixelRatio > 1;
            const isLargeScreen = window.screen.width >= 1920;
            const isHighRefresh = window.screen.refreshRate && window.screen.refreshRate >= 120;
            
            const optimizations = [];
            
            if (isRetina) {
                optimizations.push('retina');
                document.body.classList.add('retina-display');
            }
            
            if (isLargeScreen) {
                optimizations.push('large-screen');
                document.body.classList.add('large-screen');
            }
            
            if (isHighRefresh) {
                optimizations.push('high-refresh');
                document.body.classList.add('high-refresh');
            }
            
            // Apply display-specific optimizations
            if (isRetina) {
                this.enhanceChartVisibility();
            }
            
            // Log optimization results
            if (window.CFODashboard && window.CFODashboard.log) {
                window.CFODashboard.log('info', 'displayOptimization', {
                    devicePixelRatio: window.devicePixelRatio,
                    screenWidth: window.screen.width,
                    refreshRate: window.screen.refreshRate || 'unknown',
                    optimizations: optimizations
                });
            }
            
            return optimizations;
        },
        
        // Run all visual optimizations
        optimizeAll: function() {
            const startTime = performance.now();
            
            console.log('🎨 Applying visual optimizations...');
            
            try {
                this.optimizeFontRendering();
                this.enhanceColorContrast();
                this.applySharpnessFilter();
                const displayOptimizations = this.detectAndOptimizeDisplay();
                
                // Defer chart optimization to avoid blocking
                setTimeout(() => {
                    this.enhanceChartVisibility();
                }, 100);
                
                const duration = performance.now() - startTime;
                
                if (window.CFODashboard && window.CFODashboard.log) {
                    window.CFODashboard.log('perf', 'visualOptimization', {
                        duration: duration.toFixed(2) + 'ms',
                        optimizations: ['font', 'contrast', 'sharpness'].concat(displayOptimizations)
                    });
                }
                
                console.log(`🎨 Visual optimizations applied in ${duration.toFixed(2)}ms`);
                return true;
                
            } catch (error) {
                console.error('Visual optimization error:', error);
                
                if (window.CFODashboard && window.CFODashboard.log) {
                    window.CFODashboard.log('error', 'visualOptimizationFailed', {
                        error: error.message
                    });
                }
                
                return false;
            }
        }
    };
    
    // Export visual optimization utilities
    window.visualOptimization = visualOptimization;

    
    function updatePrintHeader() {
        const now = new Date();
        const dateStr = now.toLocaleDateString('ru-RU') + ' ' + now.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
        
        document.getElementById('print-date').textContent = dateStr;
        document.getElementById('print-page-name').textContent = PAGE_DEFINITIONS[currentPage]?.name || 'Обзор';
        document.getElementById('print-company').textContent = dashboardData?.meta?.company || 'ООО «Прогресс»';
    }
    
    // CSS print optimization (E1: Enhanced for A4/A3 print)
    function optimizePrintLayout() {
        // Ensure charts are properly sized and optimized for print
        Object.values(charts).forEach(chart => {
            if (chart && chart.canvas) {
                const canvas = chart.canvas;
                const context = canvas.getContext('2d');
                if (context) {
                    // High-quality print rendering
                    canvas.style.imageRendering = 'pixelated';
                    canvas.style.imageRendering = '-moz-crisp-edges';
                    canvas.style.imageRendering = 'crisp-edges';
                    
                    // Force chart redraw at higher resolution for print
                    if (chart.update && typeof chart.update === 'function') {
                        try {
                            chart.update('none');
                        } catch (e) {
                            // Ignore chart update errors during print prep
                        }
                    }
                }
            }
        });
        
        // Optimize sparklines for print
        document.querySelectorAll('.sparkline').forEach(canvas => {
            if (canvas.getContext) {
                canvas.style.imageRendering = 'pixelated';
                canvas.style.imageRendering = '-moz-crisp-edges'; 
                canvas.style.imageRendering = 'crisp-edges';
            }
        });
        
        // Ensure text elements are print-ready
        document.querySelectorAll('.kpi-value, .section-title, .metric-label').forEach(el => {
            el.style.textRendering = 'optimizeLegibility';
        });
        
        // Force layout recalculation for better print layout
        document.body.offsetHeight;
    }
    
    // Enhanced print event listeners
    window.addEventListener('beforeprint', function() {
        const startTime = performance.now();
        
        // Show print elements
        document.querySelector('.print-header').style.display = 'block';
        document.body.classList.add('printing');
        
        // Optimize layout for print
        optimizePrintLayout();
        
        // Update print header with fresh data
        updatePrintHeader();
        
        // Add print-specific classes based on current mode
        const printMode = document.body.getAttribute('data-print-mode');
        if (printMode) {
            document.body.classList.add(`print-mode-${printMode}`);
        }
        
        // Performance logging
        const duration = performance.now() - startTime;
        if (window.CFODashboard && window.CFODashboard.log) {
            window.CFODashboard.log('perf', 'beforeprint', { 
                duration: duration.toFixed(2) + 'ms',
                mode: printMode || 'default'
            });
        }
    });
    
    window.addEventListener('afterprint', function() {
        // Hide print elements
        document.querySelector('.print-header').style.display = 'none';
        document.body.classList.remove('printing');
        
        // Remove print-specific classes
        document.body.classList.remove('print-mode-current-page', 'print-mode-all-pages');
        
        // Clean up temporary print styles
        document.querySelectorAll('.kpi-value, .section-title, .metric-label').forEach(el => {
            el.style.textRendering = '';
        });
        
        if (window.CFODashboard && window.CFODashboard.log) {
            window.CFODashboard.log('info', 'afterprint', { 
                status: 'cleanup_complete' 
            });
        }
    });
    
    
    // Инициализация
    // B1: Error boundary - глобальная обработка ошибок
    var errorBoundary = {
        errors: [],
        element: null,
        
        init: function() {
            var self = this;
            
            // Глобальная обработка JS ошибок
            window.onerror = function(message, source, lineno, colno, error) {
                self.handleError({
                    type: 'javascript',
                    message: message,
                    source: source,
                    line: lineno,
                    column: colno,
                    error: error,
                    timestamp: new Date().toISOString()
                });
                return true; // Предотвращаем стандартное поведение
            };
            
            // Обработка unhandled promise rejections
            window.addEventListener('unhandledrejection', function(event) {
                self.handleError({
                    type: 'promise',
                    message: event.reason ? event.reason.message || String(event.reason) : 'Unhandled promise rejection',
                    error: event.reason,
                    timestamp: new Date().toISOString()
                });
                event.preventDefault();
            });
            
            this.createElement();
            this.log('Error boundary initialized');
        },
        
        handleError: function(errorInfo) {
            this.errors.push(errorInfo);
            this.showError(errorInfo);
            this.log('Error caught: ' + errorInfo.message, errorInfo);
            
            // Интеграция с 1С лог
            if (window.external1C && typeof window.external1C.log === 'function') {
                try {
                    window.external1C.log({
                        level: 'error',
                        event: 'dashboard_error',
                        data: errorInfo
                    });
                } catch (e) {
                    console.warn('Could not send error to 1C log:', e);
                }
            }
        },
        
        createElement: function() {
            this.element = document.createElement('div');
            this.element.className = 'error-boundary';
            this.element.style.display = 'none';
            this.element.innerHTML = '\n                <div class="error-message">⚠️ Ошибка в дашборде</div>\n                <div class="error-details"></div>\n                <div class="error-actions">\n                    <button class="error-btn copy-btn">Скопировать</button>\n                    <button class="error-btn dismiss-btn">Скрыть</button>\n                </div>\n            ';
            
            var self = this;
            this.element.addEventListener('click', function(e) {
                if (e.target === self.element) {
                    self.element.classList.toggle('expanded');
                }
            });
            
            this.element.querySelector('.copy-btn').addEventListener('click', function() {
                self.copyToClipboard();
            });
            
            this.element.querySelector('.dismiss-btn').addEventListener('click', function() {
                self.dismiss();
            });
            
            document.body.appendChild(this.element);
        },
        
        showError: function(errorInfo) {
            if (!this.element) return;
            
            var message = this.element.querySelector('.error-message');
            var details = this.element.querySelector('.error-details');
            
            message.textContent = '⚠️ ' + errorInfo.message.substring(0, 50) + (errorInfo.message.length > 50 ? '...' : '');
            
            details.textContent = '\nТип: ' + errorInfo.type + '\nСообщение: ' + errorInfo.message + '\nВремя: ' + errorInfo.timestamp + '\n\nДетали:\n' + JSON.stringify(errorInfo, null, 2);
            
            this.element.style.display = 'block';
            
            // Автоскрытие через 10 секунд если не expanded
            setTimeout(function() {
                if (this.element && !this.element.classList.contains('expanded')) {
                    this.dismiss();
                }
            }.bind(this), 10000);
        },
        
        copyToClipboard: function() {
            var text = 'CFO Dashboard Error Report\n' + '========================\n';
            this.errors.forEach(function(err, index) {
                text += '\n[' + (index + 1) + '] ' + err.timestamp + '\n';
                text += 'Type: ' + err.type + '\n';
                text += 'Message: ' + err.message + '\n';
                if (err.source) text += 'Source: ' + err.source + ':' + err.line + ':' + err.column + '\n';
                text += '---\n';
            });
            
            // Простая реализация copy to clipboard для старого WebKit
            try {
                var textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                var btn = this.element.querySelector('.copy-btn');
                var originalText = btn.textContent;
                btn.textContent = 'Скопировано!';
                setTimeout(function() {
                    btn.textContent = originalText;
                }, 1500);
            } catch (e) {
                console.warn('Could not copy to clipboard:', e);
            }
        },
        
        dismiss: function() {
            if (this.element) {
                this.element.style.display = 'none';
                this.element.classList.remove('expanded');
            }
        },
        
        log: function(message, data) {
            if (!window.__1c_log) {
                window.__1c_log = [];
            }
            window.__1c_log.push({
                timestamp: new Date().toISOString(),
                level: 'info',
                component: 'error-boundary',
                message: message,
                data: data
            });
            console.log('[ErrorBoundary]', message, data);
        },
        
        // Публичный метод для ручного репорта ошибок
        reportError: function(error, context) {
            this.handleError({
                type: 'manual',
                message: error.message || String(error),
                context: context || 'manual report',
                error: error,
                timestamp: new Date().toISOString()
            });
        }
    };
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('CFO Dashboard loading...');
        
        // Инициализируем error boundary первым
        errorBoundary.init();
        
        
        try {
            // Инициализируем переключатели, фильтры, алерты, навигацию по страницам, плотность и клавиатурную навигацию
            initializeShareModeToggle();
            initializeFilters();
            initializeAlerts();
            initializePageNavigation();
            initializeDensity();
            initializeKeyboardNavigation();
            initializeCashForecastControls();
            initializeEbitdaDrivers();
            initializeRolePresets();
            
            // Загружаем конфигурацию алертов
            loadAlertsConfig();
            
            // F2: Apply visual optimizations after UI initialization
            setTimeout(() => {
                visualOptimization.optimizeAll();
            }, 500);
            
            // Рендер дашборда
            renderDashboard(sampleData);
            console.log('CFO Dashboard loaded successfully!');
        } catch (e) {
            errorBoundary.reportError(e, 'DOMContentLoaded initialization');
        }
    });

})();
    </script>
    <script>
    (function() {
        function bind(selector, handler) {
            var el = document.querySelector(selector);
            if (el && typeof handler === 'function') {
                el.addEventListener('click', handler);
            }
        }
        bind('.export-page-btn', window.exportCurrentPage);
        bind('.export-all-btn', window.exportAllPages);
        bind('.batch-export-btn', window.executeBatchExport);
        bind('.print-controls .print-page-btn', window.printCurrentPage);
        bind('.print-controls .print-all-btn', window.printAllPages);
        bind('#recommendations-banner .banner-close', window.hideRecommendationBanner);
        bind('#recommendations-banner .banner-btn:not(.primary)', window.snoozeRecommendationBanner);
    })();
    </script>
</body>
</html>